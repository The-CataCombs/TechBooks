# 📚 개발 도서 스터디 템플릿

## 🧠 1. 책을 읽기 전에
- **기대하는 점**: 비동기 처리에 대해서는 Java레벨에 대해서 밖에 잘 알지 못해서, 조금 더 깊이 공부할 필요가 있겠다.
- **알고 싶은 개념 / 주제**: 비동기에 대한 실패 시 처리 경험이 궁금하다!

---

## 📂 2. 내용 정리 (자신의 언어로 요약)

> 각 장의 핵심 개념을 정리하고, 사례나 코드가 있다면 함께 첨부하세요.

### 📌 Chapter [번호]: [챕터 제목]

### 동기 연동과 비동기 연동
- 동기는 순차적 실행, 디버깅이 용이함
- 단, 외부 연동 시에 외부이 실패가 전체의 실패로 이어지는지를 확인해야 한다.
- 또한 외부 시스템 연동시간과의 응답 시간도 고려해야 한다.
- 대부분 같은 경우엔 비동기로 외부 연동을 처리하는게 좋음 (Ex : 로그인 이후 포이트 지급은 비동기로)
#### 비동기
- 비동기를 쓸 경우에는 별도의 스레드를 생성해서 처리함.
- 연동의 시차게 생겨도 문제가 생기지 않아야 한다.
- 일부 기능이 실패해도 재시도가 가능하다
- 나중에 수동 처리도 가능하다.
- 연동에 실패해도 무시해도 된다.

### 별도 스레드로 실행
- 직접 스레드 생성 혹은 스레드 풀을 활용해 비동기 처리가 가능하다.
- Spring같은 경우에는 메서드 레벨에 @Async 를 선언해 비동기를 처리한다. (단, 네이밍으로 Async를 넣어 비동기임을 인지하도록 하기)
- [중요] 비동기로 처리되는 로직은 왜 Try-catch로 처리되지 못한다. (메인 로직은 완료되었지만, 비동기는 예외가 나면 Try-catch는 의미없어지기 때문

#### 롤백이 안되는 Case
- @Transactional 를 활용해 처리하고 코드 중간의 메서드에서 Exception이 발생했지만, 롤백되지 않고 커밋되어버림.
- 비동기 Exception이 전파되지 않았을 수 있음
- 해결 방안 : 별도 스레드를 생성해 처리하던 것을 같은 스레드에서 처리하도록 변경한다. 이후 다시 비동기로 실행하는 방법을 찾아 적용
- Try-catch를 2중 3중으로 사용해서 발생하는 에러를 직접 잡아 처리하거나 재시도를 한다.(같은 메소드를 두번 사용) -> 좋은 방법같지 않아보인다아
#### 스레드와 메모리
- 10만개의 푸시를 보내게 되면 10만개의 스레드를 생성하고 이만큼 생성한 스레드는 그대로 메모리에 부하를 가져다준다.
- 비동기가 외부 API호출이나 네트워크 IO작업이라면 가상 스레드나 Go를 사용하는 것도 방법이다

### 메시징
- 메시징 시스템을 중간에 두어 처리하도록 한다.
  - 두 시스템간에 영향을 주지 않는다. 트래픽이 한쪽에서 증가해도 반대 쪽에서 영향을 받지는 않음
  - 확장이 용이함. 새로운 시스템에 메세지 처리를 추가해도 연결만 하면 되기 떄문에 기존 코드 수정이 필요없음
- 카프카와 레빗 MQ,Redis 선정 기준 
  - 카프카 : 높은 처리량, 수평 확장, 메시지를 파일에 보관, 1개의 토픽이 여러 파티션을 가진다. 소비자가 메세지 재처리 가능, 풀 모델 사용(소비자가 찔러서 가져간다.)
  - 레빗 MQ : 클러스터로 처리량을 늘린다. 메모리에서만 보관해 장애시 유실 가능, 큐에 등록된 순서대로 처리, 소비자에게 메세지가 전달 됐는지 확인, 푸시 모델을 사용(소비자의 성능으로 문제 생길 수 있음), 여러 프로토콜 지원
  - Redis : 지연 시간 짧고 처리량이 레빗MQ보다 높음. 구독자가 없으면 메세지 유실, 영구 메세지 지원 X, 단순함
- 이런 상황에서는 메시지 유실을 처리
  1. 오류 무시 (중요하지 않은 로그 같은 것들은 무시 가능)
  2. 재시도 (중복된 메세지가 재전송 가능하도록, 단 중복 수신은 방지해야 한다.)
  3. 실패 로그 남기기 (후처리에 대한 데이터가 담겨있어야 한다.)
- DB 트랜잭션과 관련한 문제가 생길 수 있으므로 , DB작업이 모두 끝난 이후에 전송하는 것이 최선임

#### 메시지 중복 전송
- 메시지를 중복으로 처리할 수도 있음
- 중복 메세지를 추리하기 위해선 메시지에 고유한 ID를 넣어 이미 처리했는지 확인해야 한다.
- 혹은 멱등성을 갖는 API를 만들어 처리한다. (매번 메시지를 수신해도 결과가 달라지지 않도록)
- 메시를 잘 수신하고 있는 지 모니터링도 필요

#### 글로벌 트랜잭션과 메시지 연동
- 여러 DB에 대한 변경을 한 트랜잭션으로 묶어서 처리가 가능하다. 2PC를 사용한다. (액티브 MQ가 이를 지원)
- 글로벌 트랜잭션을 사용하면 성능에 영향을 주기 때문에 필요한 상황에서만 사용하기

#### 이벤트와 커멘드
- 이벤트 : 변경(데이터 상태 변경)과 관련이 있음, 혹은 어떤 사실이 발생했다는 것을 의미
- 커멘드 : 무언가를 요청하는 메세지. 커멘드는 자신의 실행보다는 메세지를 수신한 수신자의 행동에 맞춰져 있음
  - '배송 완료함' 이라는 사실 자체가 메세지 시스템을 통해 전달되는 거라 괜찮음
- 궁극적 일관성 : 분산시스템에서 두 데이터간의 일관성을 보장하지만, 일정 시간이 지난 후에 일관성이 맞춰진다는 특징을 가진다. (일시적으로는 불일치 가능)

### 트랜잭션 아웃박스 패턴
- 메시지 데이터를 DB에 메시지를 보관했다가 사용하는 방식
- 데이터가 유실되지 않음, 같은 메세지가 두번 전송될 화률이 낮음
- 발송이후에는 상태를 변경해서 문제없이 사용하도록 한다.

### 배치 전송 
- 전통적 방식. 파일 전송 프로토콜 혹은 scp명령어를 이용해 수행
- 특정 문자를 이용해 구분, 이름과 값을 한쌍으로 묶어서 처리, Json형식으로 데이터를 전달
- 이런 시스템은 대부분 대고객사에게 DB에 데이터에 넣어주거나, 특정 망을 이용해서 데이터를 전달하는 등의 방식 있음
- 직접 DB간 연동으로 정보를 받아서 처리하는 방식도 있음.
- 연동에 실패하더라도 빈 파일을 만들어서 서비스에 문제가 없고 연동에 문제가 없었음을 증명할 수 있음

### CDC( Change Data Capture)
- 변경 데이터를 추적하고 판별해서 변경된 데이터로 작업을 수행할 수 있도록 한다.
- DB는 데이터가 변경되면 그 변경 내용을 통지한다. DB는 커밋된 데이터만 변경된 순서에 맞게 전달한다.
- 변경 데이터를 Record단위로 전달된다. 두 시스템에 대한 연동은 CDC를 통해 메시지가 그대로 전달되어 처리한다.
- 새로운 서비스 연동에서 코드를 데이터 처리가 부담스러울 때, CDC를 활용해서 데이터를 전송하고 전달받아서 처리할 수 있음

---

## 💭 더 알아보고 싶은 개념:
### ThreadPoolTaskExecutor
- 스프링은 기본적으로 ThreadPool이 존재하짐나 비동기 작업ㅇ시마다 스레드를 새로 생성해야하기 때문에 반드시 ThreadPool을 명시해 사용

```java
@Service
public static class MyService {
    @Async
    public Future<String> hello() throws InterruptedException {
        log.info("hello()");
        Thread.sleep(2000);
        return new AsyncResult<>("Hello");
    }
}
```
```java
@SpringBootApplication
@Slf4j
@RequiredArgsConstructor
public class JavaPlaygroundApplication {

    private final MyService myService;

    public static void main(String[] args) {
        // 스프링 어플리케이션 실행 후 바로 종료되도록
        try (ConfigurableApplicationContext c = SpringApplication.run(JavaPlaygroundApplication.class, args)) {
        }
    }

    @Bean
    ApplicationRunner run() {
        return args -> {
            log.info("run()");
            Future<String> f = myService.hello();
            log.info("Exit :" + f.isDone());
            log.info("Result :" + f.get());
        };
    }
}
```
```text 실행결과
2022-12-31 22:56:37.514  INFO 15625 --- [           main] o.s.b.w.embedded.tomcat.TomcatWebServer  : Tomcat started on port(s): 8080 (http) with context path ''
2022-12-31 22:56:37.525  INFO 15625 --- [           main] c.j.p.JavaPlaygroundApplication          : Started JavaPlaygroundApplication in 1.265 seconds (JVM running for 1.952)
2022-12-31 22:56:37.526  INFO 15625 --- [           main] c.j.p.JavaPlaygroundApplication          : run()
2022-12-31 22:56:37.529  INFO 15625 --- [           main] c.j.p.JavaPlaygroundApplication          : Exit :false
2022-12-31 22:56:37.533  INFO 15625 --- [      mythread-1] c.j.p.JavaPlaygroundApplication          : hello()
2022-12-31 22:56:39.538  INFO 15625 --- [           main] c.j.p.JavaPlaygroundApplication          : Result :Hello
2022-12-31 22:56:39.548  INFO 15625 --- [           main] o.apache.catalina.core.StandardService   : Stopping service [Tomcat]
```
Exit이 Hello보다 먼저 일어날 수 있음


### AWS, Kafka : Dead Letter Queue, Dead Letter Topic
- 메세지 처리가 실패하면 실패한 내용을 DLQ에 담아서 설정한 재처리 횟수만큼 재시도 가능
- 최대 시도 횟수와 현재 시도횟수를 모두 알 수 있음
- 재시도 사이에 대기할 시간, 작업을 포기하기 전 재시도 횟수 등 설정 가능

### 다른 회사의 중복 메세지 발송 사례 [링크](https://velog.io/@byeolhaha/알림톡-구조-개선기-1-구조-개선과-안정적인-OPEN-API-구축)
- 외부 연동을 이용해 알림을 발송할 때 CompletableFuture를 이용해 전용 스레드 풀 생성
- 기본 스레드 4개 최대 스레드는 4개, 대기열 큐는 100으로 설정
- 비동기 호출
- 외부 TPS는 200, LIMIT은 180으로 비동기로 보냄
- 이 메서드 완료 이후 1초 뒤에 다시 실행하도록 한다.

#### 현상
- 42만명에게 메시지 발송, 180명에게 중복 메세지를 100개 이상 보낸 문제
- OPEN API TPS를 고려하지 않아 TPS이상의 요청으로 OPENAPI도 뻗은 문제
- 알림톡을 발송하지 않은 모수를 180명 선정, 이들에게 메세지 발송

#### 원인
- CompletableFuture 대기열 큐가 터져서 TaskRejectedException(UncheckedException 발생)
- 180명에 대한 발송 (최대 스레드는 4개, 176은 대기열 큐 대기 -> 기존 설정 100 초과)
  - CompletableFuture : 성공한다는 가정하에 처리. 하지만 실패. 다시 메세지 보낼 대상으로 선정됨
- 예외가 터져서 발송이 안되었으니 스케줄러로 똑같이 계속 발송을 재시도하는 것

#### 해결
- 스레드 풀의 대기열 큐를 200으로 변경, 발송을 페이징으로 분할해서 비동기 병렬로 처리함
- 메세지 발송에 대한 스레드 풀을 100으로 증가시킴 (I/O라는 특성을 활용)
- 각 작업이 모두 끝나야만 다음단계로 진행할 수 있도록 CompletableFuture설정 변경

### KISA 데이터 연동 이슈 
- KISA에서 스팸 가입자에 대한 데이터 파일을 만들어줌
- 우리는 그 Dat파일을 받아서 처리하고 FIN파일을 생성해 완료되었음을 알 수 있도록 한다.
#### 원인 및 문제 현상
- KISA에서 데이터를 제대로 전송하지 못함 (파일 명은 존재하지만 제대로 된 파일은 아님)
- 우리는 파일 명만 읽고 비어있는 FIN파일을 반환함 (우리는 정상 처리되었다 인식)
- 하지만 제대로된 파일을 읽은게 아니어서 데이터 처리가 정상적으로 이루어지지 못했음
- 데이터 정합성 불일치 문제발생 
#### 해결
- 결국은 KISA이슈이긴 했지만,우리도 재처리나 불완전한 파일에 대한 처리 방식에는 문제가 있었기 때문에 보완 개발 필요

---

## 🌟 5. 전체 리뷰

- **별점 평가** (⭐️ 5점 만점): `⭐️⭐️⭐️⭐️⭐️`
- **책에 대한 총평**: 비동기 처리에 대한 다양한 방식을 배울 수 있었음
- **이 책을 추천한다면 어떤 사람에게?**
