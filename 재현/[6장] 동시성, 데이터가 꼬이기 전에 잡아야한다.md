# 📚 개발 도서 스터디 템플릿

## 🧠 1. 책을 읽기 전에
- **기대하는 점**: 동시성에 대한 자바레벨, 레디스 레벨 등 순차적으로 이론적으로만 알고 있는 상황인데 가능하면 테스트도 해보고 싶다..
- **알고 싶은 개념 / 주제**: 동시성 처리에 대한 다양한 시나리오와 고려해야할 점들

---

## 📂 2. 내용 정리 (자신의 언어로 요약)

### 서버와 동시 실행
- 서버가 클라이언트의 요청을 처리하는 방법
  1. 클라이언트 요청마다 스레드를 할당
  2. 비동기 or 논블로킹 IO를 사용해서 처리 (비동기이더라도 여러 스레드를 사용하는 것을 권장)
- 동시성은 일반적으로 잘 드러나지 않고 예상치 못한 순간에 나타나기 때문에 잘 의식하고 개발해야 한다.

### 잘못된 데이터 공유로 인한 문제 예시

```java
public class PayService {
  private Long payId;

  public PayResp pay(PayRequest req) {
    this.payId = getPayId() //1단계
    saveTemp(this.payId, req);
    PayResp resp = sendPayData(this.payId, ...);
    applyResponse(resp);
    return resp;
  }

  public void applyResponse(PayResp resp) {
    PayData payData = createPayDataFromResp(resp); // 2단계
    updatePayData(this.payId, payData);
  }

```
**[중요]**
- 스프링은 기본적으로 싱글톤으로 관리하기 때문에 상태값을 되도록 가지지 않는 것이 좋음
- 다른 스레드와 공유하는 값에서 문제가 발생할 가능성이 있음. 갖게 된다면,동시성 문제를 해결해야 한다.
- 사례, 배송 단계로의 전환과 고객의 주문 취소가 동시에 들어오는 경우에 대한 처리. (결제는 취소했는데, 물건이 배송되면 안됨)

### 프로세스 수준에서 동시 접근 제어
- 잠금을 사용하면 공유 자원에 접근하는 스레드를 한번에 하나로 제한할 수 있음 (임계영역)
- 만약에 동시성을 관리하지 않는 자료형을 사용하면, 데이터가 유실되거나 값이 잘못 설정될 수 있음 (일부 값이 null로 할당될 수 있음)
- ReetrantLockdml 는 한번에 한 개의 스레드에만 접근이 가능하다. 그래서 나머지는 대기를 해야함.
- 잠금 외에도 동시성을 통제하기 위해서 세마포어와 읽기쓰기 잠금이 있음

#### 세마포어
- 동시에 실행될 수 있는 스레드 수를 n개로 제한할 수 있음
- 외부 연동 서비스 같은 경우에 필요.
- 세마포어의 구현체는 permit이라고 표현한다.

#### 읽기 쓰기 잠금
- **잠금을 사용하면 동시에 읽기도 안된다.** -> 단순 잠금을 의미
- 읽기 쓰기 잠금으로 분리해서 사용하는 것을 추천
- 읽기는 한번에 여러 스레드 접근 가능, 쓰기는 한개
- 쓰기 잠금을 획득하면 읽기 잠금은 모두 대기를 해야한다. 반대의 경우도 마찬가지

#### 원자적 타입
- 매번 락을 사용하는 건 CPU효율이 떨어질 수 있음
- AtomicInteger 처럼 이런 타임을 사용하면, 여러 스레드가 공유하는 데이터를 변경할 수 있음
  
```java
lock.lock();
lock.unlock();
lock.readLock();
lock.writeLock();
try-finally
semaphore.acquire()
semaphore.release()
```

### DB와 동시성
- DB트랜잭션은 여러 조회나 쓰기를 논리적으로 하나의 연산으로 묶는다.
- DB는 대부분 명시적 잠금을 제공한다.

#### 선점 잠금(비관적 락)
- 동일한 레코드에 대해 한번에 하나의 트랜잭션만 허용한다.
- 비관락은 실패할 가능성이 높아서 비관적이라고 표현한다.
- 실패할 가능성이 높은 비관적 상황에서 배타적 락을 사용한다.

```sql
SELECT * FROM 테이블 WHERE 조건 FOR UPDATE
```
- 두 트랜잭션이 있으면 락을 하나를 잡고 그 락이 끝날 때 까지 대기한다.
- 결국에는 중요한 건 순서가 적용되어 있는가?
  
#### 비선점 잠금(낙관적 락)
- 값을 비교해서 수정하는 방식을 사용한다. (쿼리 실행을 막지 않음)
- 쿼리의 성공 가능성이 높음
- 명시적으로 잠금을 사용하지 않지만, 데이터를 조회한 시점의 값과 수정하는 시점의 값이 같은지 비교한다.

```sql
SELECT _,VERSION FROM 테이블 WHERE id = 아이디

UPDATE 테이블 SET _, version = version+1
where id = 아이디 and version = 1에서 조회한 version 값
```
- 다른 트랜잭션이 먼저 데이터를 변경하면 version값이 달라지기 때문에 Update결과가 0건이 된다. => 롤백 대상
- UPDATE결과가 0보다 크면,조회한 이후 버전 값이 바뀌지 않은 것. => 데이터 변경에 성공

#### 외부 연동과 잠금
- 외부 연동시에는 비관락을 사용하는게 좋음
- 결제 시스템은 취소되어(취소상태 변경 트랜잭션 동작) 트랜잭션이 롤백되어버릴 수 있음 (취소되지 못하고 결제 상태가 유지되는 것)

#### 증분 쿼리
- 참여자 수를 늘리는 로직도 코드 상에서 말고 쿼리상에서 처리하도록 해 문제를 해결하는 것도 좋은 방법 (DB의 원자적 연산을 따라가기)

### 잠금 사용시 주의 사항
1. 잠금 사용후에는 꼭 닫아주기 (try-finally)
2. 대기시간 지정하기 (락을 얼마나 기다릴지 지정해두고 사용하기)
3. 데드락 피하기 (대기 시간을 제한, 그리고 순서를 지정하기 or 우선순위를 지정하기)

### 단일 스레드로 처리하기
- 두 스레드 간에 데이터 공유가 필요하면 콜백이나 큐와 같은 수단을 사용해서 복제본 or 불변값을 공유한다.
- 단일 스레드로 처리하면 동시성에서 자유롭겠지만, 구조가 복잡해질 수 있음

## 💬 3. 이야기하고 싶은 질문 / 포인트
- 기본적으로 스프링은 싱글톤이기 때문에 각 요청마다 별도의 스레드를 할당받아서 처리함.(Transactional - ThreadLocal)
- 하지만, 필드값처럼 서로 공유하는 관계의 값에 대해서는 문제가 발생할 수 있음

- ❓ 질문 1:
- ReetrantLock
- CAS (Compare and swap)
- 불변은 어디까지 해야할 까?
- UPDATE 가 1보다 큰 경우?

- 💭 더 알아보고 싶은 개념:

---

## 🎯 4. 정리 & 적용 아이디어

- **내가 배운 것 한 줄 요약**:  
  → `이 장을 통해 나는 ____을 이해했다.`
- **개발에 어떻게 적용해볼까?**
    - 실제 프로젝트나 업무에 적용해볼 수 있는 아이디어

---

## 🌟 5. 전체 리뷰

- **별점 평가** (⭐️ 5점 만점): `⭐️⭐️⭐️⭐️`
- **책에 대한 총평**:
- **이 책을 추천한다면 어떤 사람에게?**
- 
