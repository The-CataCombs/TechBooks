## **ì„œë²„ì™€ ë™ì‹œ ì‹¤í–‰**

ë™ì‹œì— ì‹¤í–‰í•˜ë©´ ë™ì¼ ìˆ˜ì˜ ìš”ì²­ì„ ì²˜ë¦¬í•˜ëŠ”ë° ê°€ëŠ¥í•œ ìŠ¤ë ˆë“œí’€ì˜ í¬ê¸° ë°°ë§Œí¼ ì‹œê°„ì´ ë” ê±¸ë¦°ë‹¤~

### **ì„œë²„ê°€ ë™ì‹œì— ìš”ì²­ì²˜ë¦¬í•˜ëŠ” ë°©ë²•**

í´ë¼ì´ì–¸íŠ¸ ìš”ì²­ë§ˆë‹¤ ìŠ¤ë ˆë“œë¥¼ í• ë‹¹ â‡’ ìŠ¤í”„ë§ ë””í´íŠ¸

ë¹„ë™ê¸° IO(í˜¹ì€ ë…¼ë¸”ë¡œí‚¹ IO) â‡’ ë¦¬ì•¡íŠ¸,Node.js ë””í´íŠ¸

# ë™ì‹œì„± ë¬¸ì œê°€ ìƒê¸¸ë•Œê°€ ì–¸ì œëƒ!

### ë™ì‹œì„±(**concurrency**) ë¬¸ì œ

ì„œë¡œ ë‹¤ë¥¸ ë‘ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ê°™ì€ ë°ì´í„°ë¥¼ ì¡°íšŒ/ìˆ˜ì •í• ë•Œ ë™ì‹œì„± ë¬¸ì œê°€ ìƒê¹€

```java
public class Increaser {
    private int count = 0;

    public void inc() {
        count = count + 1;
    }

    public int getCount() {
        return count;
    }
}
```

```java
Increaser increaser = new Increaser();
Thread[] threads = new Thread[100];

for (int i = 0; i < 100; i++) {
    Thread t = new Thread(() -> {
        for (int j = 0; j < 100; j++) {
            increaser.inc();
        }
    });
    threads[i] = t;
    t.start();
}

for (Thread t : threads) {
    t.join();
}

System.out.println(increaser.getCount());

```

100ì˜ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ê³ 

ìŠ¤ë ˆë“œëŠ” increaser.inc()ë¥¼ 100ë²ˆ ì‹¤í–‰í•¨~

100*100=10000ë²ˆì˜ ì¦ê°€ ì—°ì‚°ì´ ì‹¤í–‰ë˜ì–´ì•¼ í•¨~~

but ì‹¤ì œ ê²°ê³¼ : 9982, 9973ì²˜ëŸ¼ **ë§¤ë²ˆ ë‹¤ë¥´ê³  10000ë³´ë‹¤ ì‘ê²Œ ë‚˜ì˜´**

### âš ï¸ ì›ì¸

- `count = count + 1` ì½”ë“œëŠ” 3ë‹¨ê³„ì„
    1. `count` ê°’ì„ ì½ìŒ
    2. 1ì„ ë”í•¨
    3. ê²°ê³¼ë¥¼ `count`ì— ì”€
- `count`ê°€ 5ì¼ ë•Œ, ë‘ ê°œì˜ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— `count + 1`ì„ ìˆ˜í–‰í•˜ë©´ ë‘˜ ë‹¤ 6ì„ ì €ì¥í•´ì„œ ì‹¤ì œë¡œëŠ” 1ë§Œ ì¦ê°€

### ğŸ› í•´ê²°

`synchronized`, `Lock`, ë˜ëŠ” `AtomicInteger` ê°™ì€ **ë™ê¸°í™” ë©”ì»¤ë‹ˆì¦˜**

## Thread Interference

```java
public class PayService {
    private Long payId; // ğŸš¨ ì¸ìŠ¤í„´ìŠ¤ í•„ë“œ - ìŠ¤ë ˆë“œ ì•ˆì „í•˜ì§€ ì•ŠìŒ
    
    public PayResp pay(PayRequest req) {
        this.payId = genPayId();                 
        saveTemp(this.payId, req);               
        PayResp resp = sendPayData(this.payId);  
        applyResponse(resp);                     
        return resp;
    }
    
    private void applyResponse(PayResp resp) {
        PayData payData = createPayDataFromResp(resp);        
        updatePayData(this.payId, payData); // ğŸš¨ ì˜ëª»ëœ payId ì‚¬ìš© ê°€ëŠ¥     
    }
}
```

**ì¸ìŠ¤í„´ìŠ¤ í•„ë“œ `payId`ë¥¼ ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ê³µìœ **í•˜ì—¬ ë™ì‹œì„± ë¬¸ì œ ë°œìƒ!!!

ìŠ¤ë ˆë“œ 1: payId = 1 ìƒì„± â†’ ì„ì‹œì €ì¥ â†’ ê²°ì œìš”ì²­
ìŠ¤ë ˆë“œ 2:                    payId = 2 ìƒì„± (ë®ì–´ì”€)
ìŠ¤ë ˆë“œ 1:                                      updatePayData(2, ê³ ê°Aë°ì´í„°) âŒ

- **ê³ ê° A**: ê²°ì œ ê²°ê³¼ ì†ì‹¤
- **ê³ ê° B**: ì˜ëª»ëœ ë°ì´í„°ë¡œ ë®ì–´ì¨ì§
- **ì‹¬ê°í•œ ë°ì´í„° ë¬´ê²°ì„± ë¬¸ì œ**

### í•´ê²° ë°©ë²•

```java
public PayResp pay(PayRequest req) {
    Long payId = genPayId(); // ì§€ì—­ë³€ìˆ˜ë¡œ ë³€ê²½ => thread-localì´ë‘ ì•½ê°„ ê°œë…ì´ ìœ ì‚¬í•´ì§„...
    saveTemp(payId, req);               
    PayResp resp = sendPayData(payId);  
    applyResponse(resp, payId); // payId ì „ë‹¬
    return resp;
}

private void applyResponse(PayResp resp, Long payId) {
    PayData payData = createPayDataFromResp(resp);        
    updatePayData(payId, payData);     
}
```

## DBì˜ ë™ì‹œì„± ë¬¸ì œ (Concurrency Problems)

referrence: [What is Database Concurrency? - IT Glossary | SolarWinds](https://www.solarwinds.com/resources/it-glossary/database-concurrency)

### 1. **Dirty Read (ë”í‹° ë¦¬ë“œ)**

ì•„ì§ ì»¤ë°‹ë˜ì§€ ì•Šì€ ë‹¤ë¥¸ íŠ¸ëœì­ì…˜ì˜ ë°ì´í„°ë¥¼ ì½ëŠ” ë¬¸ì œ

```sql

T1: UPDATE account SET balance = 1000 WHERE id = 1;
T2: SELECT balance FROM account WHERE id = 1;-- 1000ì„ ì½ìŒ (ì•„ì§ ì»¤ë°‹ ì•ˆë¨)
T1: ROLLBACK;-- ì‹¤ì œë¡œëŠ” ì›ë˜ ê°’ìœ¼ë¡œ ëŒì•„ê°

```

### 2. **Non-Repeatable Read (ë°˜ë³µ ë¶ˆê°€ëŠ¥í•œ ì½ê¸°)**

ê°™ì€ íŠ¸ëœì­ì…˜ ë‚´ì—ì„œ ë™ì¼í•œ ë°ì´í„°ë¥¼ ë‘ ë²ˆ ì½ì—ˆëŠ”ë° ë‹¤ë¥¸ ê°’ì´ ë‚˜ì˜¤ëŠ” ë¬¸ì œ 

```sql

T1: SELECT balance FROM account WHERE id = 1;-- 500 ì½ìŒ
T2: UPDATE account SET balance = 1000 WHERE id = 1;
T2: COMMIT;
T1: SELECT balance FROM account WHERE id = 1;-- 1000 ì½ìŒ (ë‹¤ë¥¸ ê°’!)

```

### 3. **Phantom Read (íŒ¬í…€ ë¦¬ë“œ)**

ê°™ì€ ì¡°ê±´ìœ¼ë¡œ ë‘ ë²ˆ ì¡°íšŒí–ˆëŠ”ë° ê²°ê³¼ í–‰ì˜ ìˆ˜ê°€ ë‹¬ë¼ì§€ëŠ” ë¬¸ì œ

```sql

T1: SELECT * FROM employee WHERE dept = 'IT';-- 5ëª…
T2: INSERT INTO employee VALUES ('John', 'IT');
T2: COMMIT;
T1: SELECT * FROM employee WHERE dept = 'IT';-- 6ëª… (ìƒˆë¡œìš´ í–‰!)

```

### 4. **Lost Update (ê°±ì‹  ì†ì‹¤)**

ì—¬ëŸ¬ íŠ¸ëœì­ì…˜ì´ ë™ì‹œì— ê°™ì€ ë°ì´í„°ë¥¼ ìˆ˜ì •í•  ë•Œ ì¼ë¶€ ìˆ˜ì •ì‚¬í•­ì´ ì†ì‹¤ë˜ëŠ” ë¬¸ì œ

```sql

T1: SELECT balance FROM account WHERE id = 1;-- 1000
T2: SELECT balance FROM account WHERE id = 1;-- 1000
T1: UPDATE account SET balance = 1000 + 100;-- 1100
T2: UPDATE account SET balance = 1000 + 200;-- 1200 (T1ì˜ +100ì´ ì†ì‹¤!)

```

### í•´ê²° ë°©ë²•: Transaction Isolation Level

Lock-based Protocol, Timestamp ordering, Optimistic concurrency control ë“±ì˜ ê¸°ë²• ì‚¬ìš© [Concurrency problems in DBMS Transactions - GeeksforGeeks](https://www.geeksforgeeks.org/dbms/concurrency-problems-in-dbms-transactions/)

- **READ UNCOMMITTED**: ëª¨ë“  ë¬¸ì œ ë°œìƒê°€ëŠ¥
- **READ COMMITTED**: Dirty Read ë°©ì§€
- **REPEATABLE READ**: Dirty Read, Non-Repeatable Read ë°©ì§€
- **SERIALIZABLE**: ëª¨ë“  ë¬¸ì œ ë°©ì§€

ğŸ¤”ê·¼ë° ë‹¤ë¥¸ ë¶„ë“¤ ë§ ë‹¤ ë“¤ì–´ë³´ê³  ì°¾ì•„ë´ë„ DBì—ì„œ ë™ì‹œì„± ë¬¸ì œë¥¼ í•´ê²°í•˜ëŠ”ë°ëŠ” ì—†ê³  ì• í”Œë¦¬ì¼€ì´ì…˜ë‹¨ì—ì„œ í•˜ë˜ë°?

### ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨ ì²˜ë¦¬ê°€ ì£¼ë¥˜ì¸ ì´ìœ ~

**ì„±ëŠ¥ vs ì¼ê´€ì„± íŠ¸ë ˆì´ë“œì˜¤í”„**

- **SERIALIZABLE**: ì™„ë²½í•˜ì§€ë§Œ ì„±ëŠ¥ ìµœì•… (ê±°ì˜ ìˆœì°¨ì²˜ë¦¬)
- **READ COMMITTED**: ê¸°ë³¸ê°’, ì„±ëŠ¥ ì¢‹ìŒ
- ëŒ€ë¶€ë¶„ DBëŠ” **READ COMMITTED** ê¸°ë³¸ê°’ìœ¼ë¡œ ì‚¬ìš©

**DB ê²©ë¦¬ ìˆ˜ì¤€ â†‘** = **ì„±ëŠ¥ â†“** = **ì‚¬ìš©ì ê²½í—˜ â†“**

**ë¹„ì¦ˆë‹ˆìŠ¤ ë¡œì§ì— ë§ëŠ” ì„¸ë°€í•œ ì œì–´** ê°€ëŠ¥

**ë¶„ì‚° í™˜ê²½**ì—ì„œ DB ê²©ë¦¬ ìˆ˜ì¤€ë§Œìœ¼ë¡  í•œê³„

**ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤** í™˜ê²½ì—ì„œ ì„œë¹„ìŠ¤ ê°„ ë™ì‹œì„± ì œì–´ í•„ìš”

### 2. **ì‹¤ì œ ì‚¬ìš©ë˜ëŠ” ì• í”Œë¦¬ì¼€ì´ì…˜ ë™ì‹œì„± íŒ¨í„´**

### **ë‚™ê´€ì  ë½ (Optimistic Lock)**

```java

@Entity
public class Account {
    @Version
    private Long version;// JPAê°€ ìë™ìœ¼ë¡œ ì¶©ëŒ ê²€ì‚¬
    private BigDecimal balance;
}

// ìˆ˜ì • ì‹œ version ì²´í¬í•´ì„œ ì¶©ëŒ ê°ì§€

```

### **ë¹„ê´€ì  ë½ (Pessimistic Lock)**

```java

@Lock(LockModeType.PESSIMISTIC_WRITE)
Account findByIdForUpdate(Long id);

```

### **ë¶„ì‚° ë½**

```java

// Redis ê¸°ë°˜
@RedisLock(key = "account:#{#accountId}")
public void transfer(Long accountId, BigDecimal amount) {
// ì²˜ë¦¬ ë¡œì§
}

```

### **ì´ë²¤íŠ¸ ê¸°ë°˜ ì²˜ë¦¬**

```java

// ë¹„ë™ê¸°ë¡œ ì²˜ë¦¬í•´ì„œ ë™ì‹œì„± ë¬¸ì œ íšŒí”¼
@EventListener
public void handlePaymentEvent(PaymentEvent event) {
// ìˆœì°¨ì ìœ¼ë¡œ ì²˜ë¦¬
}

```

### 3. **ì‹¤ë¬´ ì ‘ê·¼ë²•**

```

1. DB: READ COMMITTED (ê¸°ë³¸)
2. ì• í”Œë¦¬ì¼€ì´ì…˜: ë¹„ì¦ˆë‹ˆìŠ¤ ìš”êµ¬ì‚¬í•­ì— ë§ëŠ” ë½ ì „ëµ
3. ìºì‹œ: Redis ë¶„ì‚° ë½
4. ì•„í‚¤í…ì²˜: ì´ë²¤íŠ¸ ê¸°ë°˜, CQRS ë“±

```

## í”„ë¡œì„¸ìŠ¤ ìˆ˜ì¤€ì—ì„œì˜ ë™ì‹œ ì ‘ê·¼ ì œì–´

**ë‹¨ì¼ í”„ë¡œì„¸ìŠ¤ ë‚´ì—ì„œ ë™ì‹œì„± ì œì–´**

### ğŸ”’ ì ê¸ˆ(lock)ì„ ì´ìš©í•œ ì ‘ê·¼ ì œì–´

í”„ë¡œì„¸ìŠ¤ ìˆ˜ì¤€ì—ì„œ ë°ì´í„°ë¥¼ ë™ì‹œì— ìˆ˜ì •í•˜ëŠ” ê²ƒì„ ë§‰ê¸° ìœ„í•œ ì¼ë°˜ì ì¸ ë°©ë²•ì€ **ì ê¸ˆ(lock)** ì„ ì‚¬ìš©í•˜ëŠ” ê²ƒì´ë‹¤. ì ê¸ˆì„ ì‚¬ìš©í•˜ë©´ **ê³µìœ  ìì›ì— ì ‘ê·¼í•˜ëŠ” ìŠ¤ë ˆë“œë¥¼ í•œ ë²ˆì— í•˜ë‚˜ë¡œ ì œí•œ**í•  ìˆ˜ ìˆë‹¤.

ì ê¸ˆì„ ì‚¬ìš©í•˜ëŠ” ì¼ë°˜ì ì¸ íë¦„ì€ ë‹¤ìŒê³¼ ê°™ë‹¤:

1. **ì ê¸ˆì„ íšë“í•œë‹¤**
2. **ê³µìœ  ìì›ì— ì ‘ê·¼ (ì„ê³„ ì˜ì—­)**
3. **ì ê¸ˆì„ í•´ì œí•œë‹¤**

<aside>
ğŸ’¡

**Critical Section ì„ê³„ ì˜ì—­**

**ë™ì‹œì— ë‘˜ ì´ìƒì˜ ìŠ¤ë ˆë“œë‚˜ í”„ë¡œì„¸ìŠ¤ê°€ ì ‘ê·¼í•˜ë©´ ì•ˆ ë˜ëŠ” ê³µìœ  ìì›(ë©”ëª¨ë¦¬, íŒŒì¼ â€¦)ì— ì ‘ê·¼í•˜ëŠ” ì½”ë“œ ì˜ì—­**

</aside>

`ReentrantLock`ì„ ì‚¬ìš©í•´ ë™ì‹œì— HashMapì„ ìˆ˜ì •í•˜ëŠ” ê²ƒì„ ë§‰ëŠ” ì½”ë“œ

```java

public class UserSessions {
    private Lock lock = new ReentrantLock();
    private Map<String, UserSession> sessions = new HashMap<>();

    public void addUserSession(UserSession session) {
        lock.lock(); // ì ê¸ˆ íšë“ (ëŒ€ê¸°)
        try {
            sessions.put(session.getSessionId(), session); // ê³µìœ  ìì› ì ‘ê·¼
        } finally {
            lock.unlock(); // ì ê¸ˆ í•´ì œ
        }
    }

    public UserSession getUserSession(String sessionId) {
        lock.lock();
        try {
            return sessions.get(sessionId);
        } finally {
            lock.unlock();
        }
    }
}

```

`ReentrantLock`ì„ ì´ìš©í•˜ì—¬ `sessions`ë¼ëŠ” `HashMap`ì— ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ì ‘ê·¼í•˜ì—¬ ë°ì´í„°ë¥¼ ìˆ˜ì •í•˜ê±°ë‚˜ ì½ì„ ë•Œ ë°œìƒí•  ìˆ˜ ìˆëŠ” **race conditionì„** ë°©ì§€

ì±…ì—ì„œ ìê¾¸ í—·ê°ˆë¦¬ê²Œ í•´ì„œ ì§šê³ ë„˜ì–´ê°â€¦

<aside>
ğŸ’¡

## ë™ì‹œì„± ì œì–´ ë ˆë²¨ êµ¬ë¶„

### 1. **ìŠ¤ë ˆë“œ ìˆ˜ì¤€ (Thread Level)** = **í”„ë¡œì„¸ìŠ¤ ë‚´ë¶€**

- **ê°™ì€ JVM ì•ˆì—ì„œ** ì—¬ëŸ¬ ìŠ¤ë ˆë“œ ê°„ ë™ì‹œì„± ì œì–´
- `synchronized`, `ReentrantLock`, `volatile`, `AtomicInteger` ë“±
- **ë©”ëª¨ë¦¬ ê³µìœ ** ê¸°ë°˜

### 2. **í”„ë¡œì„¸ìŠ¤ ìˆ˜ì¤€ (Process Level)** = **ì„œë²„ ê°„/ì¸ìŠ¤í„´ìŠ¤ ê°„**

- **ì—¬ëŸ¬ JVMê°„** ë™ì‹œì„± ì œì–´ â‡’ ğŸ˜ŠMSAì—ì„œ ëª¨ë“ˆ í•˜ë‚˜ë‹¹ jvm í•˜ë‚˜!!
- ë¶„ì‚° ë½, íŒŒì¼ ë½, Redis ë½ ë“±
- **ë„¤íŠ¸ì›Œí¬ í†µì‹ ** ê¸°ë°˜

### 3. **ì• í”Œë¦¬ì¼€ì´ì…˜ ìˆ˜ì¤€ (Application Level)**

- **ì•„í‚¤í…ì²˜ ì„¤ê³„**ë¡œ ë™ì‹œì„± ë¬¸ì œ íšŒí”¼
- ì´ë²¤íŠ¸ ê¸°ë°˜, CQRS, ë©”ì‹œì§€ í, ë‹¨ì¼ ìŠ¤ë ˆë“œ ë“±

### 4. **DB ìˆ˜ì¤€ (Database Level)**

- **ë°ì´í„°ë² ì´ìŠ¤**ì—ì„œ ì œê³µí•˜ëŠ” ë™ì‹œì„± ì œì–´
- íŠ¸ëœì­ì…˜, ë¹„ê´€ì  ë½, ë‚™ê´€ì  ë½, ê²©ë¦¬ ìˆ˜ì¤€ ë“±
</aside>

## ìê¾¸ í—·ê°ˆë ¤ì„œ ì´ì •ë¦¬ë¥¼ í•´ë´„

ì¼ë‹¨ ì²˜ìŒ ë³¸ ReentrantLock

<aside>
ğŸ§

### Re-entrant = Re + Entrant

"ë‹¤ì‹œ ë“¤ì–´ê°ˆ ìˆ˜ ìˆëŠ”â€

ì˜ì–´ë‹¨ì–´ ê·¸ìì²´ë¥¼ ì´í•´í•˜ëŠ”ê²Œ ì•„ë‹ˆë©´ ê¸°ì–µì— ì˜ ë‚¨ì§€ ì•Šì•„ìš”â€¦

ê°™ì€ ì‚¬ëŒ(ìŠ¤ë ˆë“œ)ì€ ìì‹ ì´ ì´ë¯¸ ê°€ì§€ê³  ìˆëŠ” ë½ì„ ë¶€ë‹´ ì—†ì´ ë‹¤ì‹œ ì‚¬ìš©í•  ìˆ˜ ìˆë‹¤!

### âŒ ì¬ì§„ì… ë¶ˆê°€ëŠ¥í•œ ë½ (ê°€ìƒì˜ ì˜ˆì‹œ)

```jsx
// ì´ëŸ° ë½ì´ ìˆë‹¤ë©´...
SimpleLock lock = new SimpleLock();

public void ì—„ë§ˆê°€_ìš”ë¦¬í•˜ê¸°() {
    lock.lock();  // ë¶€ì—Œ ì ìœ 
    try {
        ì¬ë£Œ_ì¤€ë¹„í•˜ê¸°();
        ì¡°ë¯¸ë£Œ_ê°€ì ¸ì˜¤ê¸°();  // ì´ ë©”ì„œë“œë„ ë¶€ì—Œì„ ì¨ì•¼ í•¨
    } finally {
        lock.unlock();
    }
}

public void ì¡°ë¯¸ë£Œ_ê°€ì ¸ì˜¤ê¸°() {
    lock.lock();  // ğŸ’¥ ë°ë“œë½! ì—„ë§ˆê°€ ì´ë¯¸ ë¶€ì—Œì„ ì“°ê³  ìˆëŠ”ë° 
                  //    ì—„ë§ˆ ìì‹ ì´ ë‹¤ì‹œ ë¶€ì—Œì— ë“¤ì–´ê°€ë ¤ê³  í•¨
    try {
        ì†Œê¸ˆ_ê°€ì ¸ì˜¤ê¸°();
    } finally {
        lock.unlock();
    }
}
```

### âœ… ì¬ì§„ì… ê°€ëŠ¥í•œ ë½ (ReentrantLock)

```java

ReentrantLock lock = new ReentrantLock();

public void ì—„ë§ˆê°€_ìš”ë¦¬í•˜ê¸°() {
    lock.lock();  // ë¶€ì—Œ ì ìœ  (ì¹´ìš´íŠ¸: 1)
    try {
        ì¬ë£Œ_ì¤€ë¹„í•˜ê¸°();
        ì¡°ë¯¸ë£Œ_ê°€ì ¸ì˜¤ê¸°();  // ê°™ì€ ì‚¬ëŒ(ìŠ¤ë ˆë“œ)ì´ë‹ˆê¹Œ ë“¤ì–´ê°ˆ ìˆ˜ ìˆìŒ
    } finally {
        lock.unlock();  // ì¹´ìš´íŠ¸: 0, ì‹¤ì œë¡œ ë¶€ì—Œ ë¹„ì›€
    }
}

public void ì¡°ë¯¸ë£Œ_ê°€ì ¸ì˜¤ê¸°() {
    lock.lock();  // âœ… ì„±ê³µ! ì—„ë§ˆë‹ˆê¹Œ ë“¤ì–´ê°ˆ ìˆ˜ ìˆìŒ (ì¹´ìš´íŠ¸: 2)
    try {
        ì†Œê¸ˆ_ê°€ì ¸ì˜¤ê¸°();
    } finally {
        lock.unlock();  // ì¹´ìš´íŠ¸: 1, ì•„ì§ ì—„ë§ˆê°€ ë¶€ì—Œ ì‚¬ìš© ì¤‘
    }
}
```

ì• ì´ˆì— ì™œ ì¬ì§„ì…ì„ í•´ì•¼í•˜ëŠ”ë°â€¦? ì‹¶ì–´ì„œ ì°¾ì•„ë³¸

### ì¬ì§„ì…ì„ í•´ì•¼í•˜ëŠ” ê²½ìš°ì˜ ìˆ˜

### 1. **ë©”ì„œë“œ ì²´ì¸ í˜¸ì¶œ**

```java

public void í°ì¼_ì²˜ë¦¬í•˜ê¸°() {
    lock.lock();
    try {
        ì‘ì€ì¼1_í•˜ê¸°();// ì´ê²ƒë„ ë½ì´ í•„ìš”
        ì‘ì€ì¼2_í•˜ê¸°();// ì´ê²ƒë„ ë½ì´ í•„ìš”
        ì‘ì€ì¼3_í•˜ê¸°();// ì´ê²ƒë„ ë½ì´ í•„ìš”
    } finally {
        lock.unlock();
    }
}

```

### 2. **ì¬ê·€ í•¨ìˆ˜**

```java

public void í´ë”_ì •ë¦¬í•˜ê¸°(Folder folder) {
    lock.lock();
    try {
        íŒŒì¼_ì •ë¦¬í•˜ê¸°(folder);
        for (Folder í•˜ìœ„í´ë” : folder.getSubFolders()) {
            í´ë”_ì •ë¦¬í•˜ê¸°(í•˜ìœ„í´ë”);// ì¬ê·€ í˜¸ì¶œ!
        }
    } finally {
        lock.unlock();
    }
}

```

### 3. **ì½œë°± í•¨ìˆ˜**

```java

public void ì´ë²¤íŠ¸_ì²˜ë¦¬í•˜ê¸°() {
    lock.lock();
    try {
// ì´ë²¤íŠ¸ ì²˜ë¦¬ ì¤‘ì— ì½œë°±ì´ í˜¸ì¶œë  ìˆ˜ ìˆìŒ
        ì½œë°±í•¨ìˆ˜_í˜¸ì¶œ();// ì´ í•¨ìˆ˜ê°€ ë‹¤ì‹œ ë½ì„ ìš”ì²­í•  ìˆ˜ ìˆìŒ
    } finally {
        lock.unlock();
    }
}

```

</aside>

# ë™ì‹œì„± ì œì–´ 4ë ˆë²¨ ì •ë¦¬ë³¸

## ğŸ§µ ìŠ¤ë ˆë“œ ë ˆë²¨ (Thread Level)

> ë²”ìœ„: í•˜ë‚˜ì˜ JVM ì•ˆì—ì„œ ì—¬ëŸ¬ ìŠ¤ë ˆë“œ ê°„ ë™ì‹œì„± ì œì–´
> 

## Java ê¸°ì¤€~

### **Atomic í´ë˜ìŠ¤ë“¤**

```java

AtomicInteger, AtomicLong, AtomicBoolean, AtomicReference
AtomicIntegerArray, AtomicLongArray, AtomicReferenceArray
LongAdder, DoubleAdder// ë†’ì€ ê²½í•© ìƒí™©ì—ì„œ ë” ë¹ ë¦„// ì˜ˆì‹œ: LongAdder vs AtomicLong
LongAdder adder = new LongAdder();
adder.increment();// ë‚´ë¶€ì ìœ¼ë¡œ ì—¬ëŸ¬ Cellë¡œ ë¶„ì‚°í•˜ì—¬ ê²½í•© ì¤„ì„

```

### **ë½**

```java

// ReadWriteLock - ì½ê¸°ëŠ” ë™ì‹œ, ì“°ê¸°ëŠ” ë°°íƒ€
ReadWriteLock rwLock = new ReentrantReadWriteLock();
rwLock.readLock().lock();// ì—¬ëŸ¬ ìŠ¤ë ˆë“œ ë™ì‹œ ì½ê¸° ê°€ëŠ¥
rwLock.writeLock().lock();// ë°°íƒ€ì  ì“°ê¸°// StampedLock - ë‚™ê´€ì  ì½ê¸° ì§€ì› (Java 8+)
StampedLock sl = new StampedLock();
long stamp = sl.tryOptimisticRead();// ë‚™ê´€ì  ì½ê¸°
if (!sl.validate(stamp)) {// ê²€ì¦ ì‹¤íŒ¨ ì‹œ
    stamp = sl.readLock();// ì‹¤ì œ ë½ íšë“
}

```

### **ë™ì‹œì„± ì»¬ë ‰ì…˜**

```java

// Lock-free ìë£Œêµ¬ì¡°ë“¤
ConcurrentHashMap<String, Integer> map = new ConcurrentHashMap<>();
ConcurrentLinkedQueue<String> queue = new ConcurrentLinkedQueue<>();
ConcurrentSkipListMap<String, Integer> sortedMap = new ConcurrentSkipListMap<>();

// Blocking ìë£Œêµ¬ì¡°ë“¤
BlockingQueue<String> bq = new ArrayBlockingQueue<>(100);
bq.put("item");// íê°€ ê°€ë“ ì°¨ë©´ ë¸”ë¡œí‚¹
bq.take();// íê°€ ë¹„ì–´ìˆìœ¼ë©´ ë¸”ë¡œí‚¹

```

### **ë™ê¸°í™” ìœ í‹¸ë¦¬í‹°ë“¤**

```java

// CountDownLatch - Nê°œ ì‘ì—… ì™„ë£Œ ëŒ€ê¸°
CountDownLatch latch = new CountDownLatch(3);
latch.countDown();// ì¹´ìš´íŠ¸ ê°ì†Œ
latch.await();// 0ì´ ë  ë•Œê¹Œì§€ ëŒ€ê¸°// CyclicBarrier - Nê°œ ìŠ¤ë ˆë“œê°€ íŠ¹ì • ì§€ì ì—ì„œ ë§Œë‚  ë•Œê¹Œì§€ ëŒ€ê¸°
CyclicBarrier barrier = new CyclicBarrier(3, () -> System.out.println("All arrived!"));
barrier.await();

// Semaphore - í—ˆê°€ì¦ ê¸°ë°˜ ì ‘ê·¼ ì œì–´
Semaphore semaphore = new Semaphore(2);// 2ê°œ í—ˆê°€ì¦
semaphore.acquire();// í—ˆê°€ì¦ íšë“
semaphore.release();// í—ˆê°€ì¦ ë°˜ë‚©// Phaser - ë‹¨ê³„ë³„ ë™ê¸°í™” (Java 7+)
Phaser phaser = new Phaser(3);// 3ê°œ ì°¸ê°€ì
phaser.arriveAndAwaitAdvance();// í˜„ì¬ ë‹¨ê³„ ì™„ë£Œ í›„ ë‹¤ìŒ ë‹¨ê³„ ëŒ€ê¸°

```

### **Fork/Join í”„ë ˆì„ì›Œí¬**

```java

// ë¶„í•  ì •ë³µ ì•Œê³ ë¦¬ì¦˜ì— ìµœì í™”
class MergeSort extends RecursiveAction {
    @Override
    protected void compute() {
        if (array.length < THRESHOLD) {
// ì§ì ‘ ì •ë ¬
        } else {
// ë¶„í•  í›„ ë³‘ë ¬ ì²˜ë¦¬
            invokeAll(new MergeSort(left), new MergeSort(right));
        }
    }
}

ForkJoinPool pool = new ForkJoinPool();
pool.invoke(new MergeSort(array));

```

### **CompletableFutureì™€ ë¹„ë™ê¸° ì²˜ë¦¬**

```java

CompletableFuture<String> future = CompletableFuture
    .supplyAsync(() -> "Hello")
    .thenCompose(s -> CompletableFuture.supplyAsync(() -> s + " World"))
    .thenApply(String::toUpperCase);

// ì—¬ëŸ¬ ì‘ì—… ì¡°í•©
CompletableFuture.allOf(future1, future2, future3).join();

```

### **Thread-Local Storage**

```java

// ìŠ¤ë ˆë“œë³„ ë…ë¦½ì ì¸ ë³€ìˆ˜
ThreadLocal<SimpleDateFormat> formatter = ThreadLocal.withInitial(
    () -> new SimpleDateFormat("yyyy-MM-dd")
);

// ìƒì† ê°€ëŠ¥í•œ ThreadLocal
InheritableThreadLocal<String> context = new InheritableThreadLocal<>();

```

### **ë©”ëª¨ë¦¬ ëª¨ë¸ ê¸°ë°˜ ì œì–´**

```java

// VarHandle - ë©”ëª¨ë¦¬ ì•¡ì„¸ìŠ¤ì— ëŒ€í•œ ì„¸ë°€í•œ ì œì–´ (Java 9+)
VarHandle vh = MethodHandles.lookup()
    .findVarHandle(MyClass.class, "field", int.class);

vh.setVolatile(obj, newValue);// volatile ì“°ê¸°
vh.compareAndSet(obj, expected, new);// CAS ì—°ì‚°
vh.getAndAdd(obj, delta);// atomic add// MethodHandleì„ í†µí•œ ë™ì  ë©”ì„œë“œ í˜¸ì¶œ
MethodHandle mh = lookup.findVirtual(String.class, "length", methodType(int.class));

```

### **Lock-Free ì•Œê³ ë¦¬ì¦˜ íŒ¨í„´**

```java

// Treiber Stack (Lock-free Stack)
public class LockFreeStack<T> {
    private final AtomicReference<Node<T>> head = new AtomicReference<>();

    public void push(T item) {
        Node<T> newNode = new Node<>(item);
        Node<T> currentHead;
        do {
            currentHead = head.get();
            newNode.next = currentHead;
        } while (!head.compareAndSet(currentHead, newNode));
    }
}

// Michael & Scott Queue (Lock-free Queue)// ConcurrentLinkedQueueì˜ ê¸°ë°˜ ì•Œê³ ë¦¬ì¦˜

```

### synchronized

**ì–¸ì œ ì¨?** ê°„ë‹¨í•œ ë©”ì„œë“œë‚˜ ë¸”ë¡ì„ ë³´í˜¸í•  ë•Œ

**ì–´ë–»ê²Œ?** JVMì´ ìë™ìœ¼ë¡œ lock/unlock ê´€ë¦¬

**íŠ¹ì§•**:

- ìë™ lock/unlock (try-finally ë¶ˆí•„ìš”)
- JVM ì°¨ì›ì—ì„œ ê´€ë¦¬ (ë°”ì´íŠ¸ì½”ë“œ monitorenter/monitorexit)
- ë¸”ë¡œí‚¹ ë°©ì‹, íƒ€ì„ì•„ì›ƒ ì—†ìŒ
- ì¬ì§„ì… ê°€ëŠ¥ (ê°™ì€ ìŠ¤ë ˆë“œê°€ ì¤‘ë³µ íšë“ ê°€ëŠ¥)

**ì¥ì **: ì½”ë“œ ê°„ë‹¨, ìë™ ê´€ë¦¬
**ë‹¨ì **: ìœ ì—°ì„± ë¶€ì¡±, íƒ€ì„ì•„ì›ƒ/ì¸í„°ëŸ½íŠ¸ ë¶ˆê°€, ê³µì •ì„± ì œì–´ ë¶ˆê°€

```java

public class SimpleCounter {
    private int count = 0;

// ë©”ì„œë“œ ë ˆë²¨ ë™ê¸°í™”
    public synchronized void increment() {
        count++;
    }

// ë¸”ë¡ ë ˆë²¨ ë™ê¸°í™”
    public void decrement() {
        synchronized(this) {
            count--;
        }
    }

// ì¬ì§„ì… ì˜ˆì‹œ
    public synchronized void reentrantExample() {
        anotherSyncMethod();// ê°™ì€ ìŠ¤ë ˆë“œê°€ ë‹¤ì‹œ ë½ íšë“ ê°€ëŠ¥
    }

    public synchronized void anotherSyncMethod() {
        System.out.println("ì¬ì§„ì… ì„±ê³µ!");
    }
}

```

### ReentrantLock

**ì–¸ì œ ì¨?** ì„¸ë°€í•œ ì œì–´ê°€ í•„ìš”í•  ë•Œ (íƒ€ì„ì•„ì›ƒ, ìƒíƒœ í™•ì¸ ë“±)

**ì–´ë–»ê²Œ?** ëª…ì‹œì ìœ¼ë¡œ lock()/unlock() í˜¸ì¶œ

**íŠ¹ì§•**:

- íƒ€ì„ì•„ì›ƒ ì§€ì› (`tryLock(timeout)`)
- ë½ ìƒíƒœ í™•ì¸ (`isLocked()`, `isHeldByCurrentThread()`)
- ê³µì •ì„± ì„¤ì • ê°€ëŠ¥ (`new ReentrantLock(true)`)
- ì¸í„°ëŸ½íŠ¸ ì‘ë‹µ (`lockInterruptibly()`)
- ì¡°ê±´ ë³€ìˆ˜ ì§€ì› (`Condition`)

**ì¥ì **: ìœ ì—°í•œ ì œì–´, ë°ë“œë½ ë°©ì§€ ê¸°ëŠ¥
**ë‹¨ì **: ì½”ë“œ ë³µì¡, unlock ëˆ„ë½ ìœ„í—˜

```java

public class AdvancedCounter {
    private int count = 0;
    private final ReentrantLock lock = new ReentrantLock(true);// ê³µì •ì„±
    private final Condition notEmpty = lock.newCondition();

    public void increment() {
        lock.lock();
        try {
            count++;
            notEmpty.signalAll();// ëŒ€ê¸° ì¤‘ì¸ ìŠ¤ë ˆë“œ ê¹¨ìš°ê¸°
        } finally {
            lock.unlock();
        }
    }

// íƒ€ì„ì•„ì›ƒ ìˆëŠ” ë½ ì‹œë„
    public boolean tryIncrement() {
        try {
            if (lock.tryLock(5, TimeUnit.SECONDS)) {
                try {
                    count++;
                    return true;
                } finally {
                    lock.unlock();
                }
            }
            return false;
        } catch (InterruptedException e) {
            return false;
        }
    }

// ì¡°ê±´ë¶€ ëŒ€ê¸°
    public void waitUntilNotEmpty() throws InterruptedException {
        lock.lock();
        try {
            while (count == 0) {
                notEmpty.await();// count > 0ê¹Œì§€ ëŒ€ê¸°
            }
        } finally {
            lock.unlock();
        }
    }
}

```

### volatile

**ì–¸ì œ ì¨?** ë‹¨ìˆœí•œ í”Œë˜ê·¸ë‚˜ ìƒíƒœê°’ ê³µìœ í•  ë•Œ

**ì–´ë–»ê²Œ?** ë³€ìˆ˜ ì•ì— volatile í‚¤ì›Œë“œ ë¶™ì„

**íŠ¹ì§•**:

- ê°€ì‹œì„± ë³´ì¥ (ëª¨ë“  ìŠ¤ë ˆë“œê°€ ìµœì‹  ê°’ í™•ì¸)
- ì›ìì„± ë³´ì¥ ì•ˆ ë¨ (ì½ê¸°/ì“°ê¸°ë§Œ ì›ìì )
- CPU ìºì‹œ ìš°íšŒí•´ì„œ ë©”ì¸ ë©”ëª¨ë¦¬ ì§ì ‘ ì ‘ê·¼

**ì¥ì **: ê°„ë‹¨, ì„±ëŠ¥ ì¢‹ìŒ
**ë‹¨ì **: ë³µí•© ì—°ì‚° (count++) ì•ˆì „í•˜ì§€ ì•ŠìŒ

```java

public class StatusManager {
    private volatile boolean running = true;// ê°€ì‹œì„± ë³´ì¥
    private volatile String status = "READY";

    public void stop() {
        running = false;// ëª¨ë“  ìŠ¤ë ˆë“œê°€ ì¦‰ì‹œ í™•ì¸ ê°€ëŠ¥
    }

    public boolean isRunning() {
        return running;// í•­ìƒ ìµœì‹  ê°’
    }
}

```

### Atomic íƒ€ì…ë“¤

**ì–¸ì œ ì¨?** ê°„ë‹¨í•œ ìˆ«ì ì—°ì‚°ì„ ë½ ì—†ì´ ì•ˆì „í•˜ê²Œ í•  ë•Œ

**ì–´ë–»ê²Œ?** CAS(Compare-And-Swap) ì—°ì‚° ì‚¬ìš©

**íŠ¹ì§•**:

- ë½ ì—†ëŠ” ì›ìì  ì—°ì‚°
- ë†’ì€ ì„±ëŠ¥ (ìŠ¤í•€ë½ ë°©ì‹)
- ë‹¤ì–‘í•œ íƒ€ì… ì§€ì› (Integer, Long, Boolean, Referenc

**ì¥ì **: ë½ë³´ë‹¤ ë¹ ë¦„, ë°ë“œë½ ì—†ìŒ
**ë‹¨ì **: ë³µì¡í•œ ë¡œì§ì—” ë¶€ì í•©, ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ ë†’ìŒ

```java

public class AtomicCounters {
    private final AtomicInteger counter = new AtomicInteger(0);
    private final AtomicReference<String> status = new AtomicReference<>("READY");
    private final LongAdder highContentionCounter = new LongAdder();// ê²½í•© ë§ì„ ë•Œ

    public int incrementAndGet() {
        return counter.incrementAndGet();// ì›ìì  +1
    }

// CAS ì—°ì‚°
    public boolean updateStatus(String expected, String newValue) {
        return status.compareAndSet(expected, newValue);
    }

// ë†’ì€ ê²½í•© ìƒí™©ì—ì„œ ë” ë¹ ë¦„
    public void incrementHighContention() {
        highContentionCounter.increment();
    }
}

```

### ReadWriteLock

**ì–¸ì œ ì¨?** ì½ê¸°ëŠ” ë§ê³  ì“°ê¸°ëŠ” ì ì„ ë•Œ

**ì–´ë–»ê²Œ?** ì½ê¸°ìš©/ì“°ê¸°ìš© ë½ ë¶„ë¦¬

**íŠ¹ì§•**:

- ì½ê¸°ë¼ë¦¬ëŠ” ë™ì‹œ ì‹¤í–‰ ê°€ëŠ¥
- ì“°ê¸°ëŠ” ë°°íƒ€ì 
- ì“°ê¸° ì¤‘ì—” ì½ê¸°ë„ ì°¨ë‹¨

**ì¥ì **: ì½ê¸° ì„±ëŠ¥ í–¥ìƒ
**ë‹¨ì **: ì“°ê¸° ê¸°ì•„ í˜„ìƒ ê°€ëŠ¥, ë³µì¡ì„± ì¦ê°€

```java

public class CacheManager {
    private final Map<String, Object> cache = new HashMap<>();
    private final ReadWriteLock lock = new ReentrantReadWriteLock();
    private final Lock readLock = lock.readLock();
    private final Lock writeLock = lock.writeLock();

    public Object get(String key) {
        readLock.lock();// ì—¬ëŸ¬ ìŠ¤ë ˆë“œ ë™ì‹œ ì½ê¸° ê°€ëŠ¥
        try {
            return cache.get(key);
        } finally {
            readLock.unlock();
        }
    }

    public void put(String key, Object value) {
        writeLock.lock();// ì“°ê¸°ëŠ” í˜¼ìë§Œ
        try {
            cache.put(key, value);
        } finally {
            writeLock.unlock();
        }
    }
}

```

### ì„¸ë§ˆí¬ì–´(Semaphore) - ì ‘ê·¼ ìˆ˜ ì œí•œ

  **** ë™ì‹œì— ì‹¤í–‰í•  ìˆ˜ ìˆëŠ” ìŠ¤ë ˆë“œ ìˆ˜ë¥¼ ì œí•œ

- permit(í—ˆìš© ê°œìˆ˜)ì„ ì´ìš©í•´ ìƒì„±
- ì´ì§„ ì„¸ë§ˆí¬ì–´(1ê°œ) vs ê³„ìˆ˜ ì„¸ë§ˆí¬ì–´(Nê°œ)
- P ì—°ì‚°(acquire) / V ì—°ì‚°(release)
- Nê°œì˜ í—ˆê°€ ê´€ë¦¬
- acquire()/release()ë¡œ í—ˆê°€ íšë“/ë°˜í™˜
- íƒ€ì„ì•„ì›ƒ ì§€ì›

**ì¥ì **: ë¦¬ì†ŒìŠ¤ ì‚¬ìš©ëŸ‰ ì œì–´ ê°€ëŠ¥
**ë‹¨ì **: í—ˆê°€ ê´€ë¦¬ ë³µì¡

```java

@Service
public class ExternalApiClient {
    private final Semaphore semaphore = new Semaphore(5);// ìµœëŒ€ 5ê°œ

    public String callApi(String request) {
        try {
            semaphore.acquire();// í—ˆê°€ íšë“// ì™¸ë¶€ API í˜¸ì¶œ (ìµœëŒ€ 5ê°œ ë™ì‹œ ì‹¤í–‰)
            return httpClient.call(request);
        } catch (InterruptedException e) {
            throw new RuntimeException("ì¤‘ë‹¨ë¨", e);
        } finally {
            semaphore.release();// í—ˆê°€ ë°˜í™˜
        }
    }
}

```

### ThreadLocal

**ì–¸ì œ ì¨?** ìŠ¤ë ˆë“œë³„ë¡œ ë…ë¦½ì ì¸ ê°’ ì €ì¥í•  ë•Œ

**ì–´ë–»ê²Œ?** ìŠ¤ë ˆë“œë§ˆë‹¤ ë³„ë„ ì €ì¥ ê³µê°„ ì œê³µ

**íŠ¹ì§•**:

- ìŠ¤ë ˆë“œë³„ ë…ë¦½ ë³€ìˆ˜
- ìƒì† ê°€ëŠ¥ (InheritableThreadLocal)

**ì¥ì **: ë™ì‹œì„± ë¬¸ì œ ì—†ìŒ
**ë‹¨ì **: ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ìœ„í—˜, ìŠ¤ë ˆë“œ í’€ì—ì„œ ë¬¸ì œ ê°€ëŠ¥

```java

public class UserContextHolder {
    private static final ThreadLocal<UserContext> contextHolder = new ThreadLocal<>();

    public static void setContext(UserContext context) {
        contextHolder.set(context);
    }

    public static UserContext getContext() {
        return contextHolder.get();
    }

    public static void clear() {
        contextHolder.remove();// ë°˜ë“œì‹œ ì •ë¦¬!
    }
}

```

## ì»¤ìŠ¤í…€ë„ ê°€ëŠ¥í•˜ë‹¤~

Atomic ì—°ì‚°ì„ CASë§ê³ ë„ ì•Œì•„ë³´ì~

â‡’ í•˜ê³  CAS ABA ë¬¸ì œ í•´ê²°ì±…ì´ gcë‘ ë¹„ìŠ·í•˜ê¸¸ë˜ ì•ˆë“œë¡œë©”ë‹¤ë¡œ ê°

## ğŸ–¥ï¸ í”„ë¡œì„¸ìŠ¤ ë ˆë²¨ (Process Level)

> ë²”ìœ„: ì—¬ëŸ¬ JVM(ì„œë²„) ê°„ ë™ì‹œì„± ì œì–´
> 

### Redis ë¶„ì‚° ë½

**ì–¸ì œ ì¨?** ì—¬ëŸ¬ ì„œë²„ì—ì„œ ê°™ì€ ì‘ì—… ì¤‘ë³µ ì‹¤í–‰ ë°©ì§€í•  ë•Œ

**ì–´ë–»ê²Œ?** Redisì˜ SETNX ëª…ë ¹ì–´ ì´ìš©

**íŠ¹ì§•**:

- ë¹ ë¥¸ ì†ë„
- TTLë¡œ ìë™ í•´ì œ
- ë„¤íŠ¸ì›Œí¬ ì¥ì•  ì‹œ ë¬¸ì œ ê°€ëŠ¥

**ì¥ì **: ì„±ëŠ¥ ì¢‹ìŒ, êµ¬í˜„ ê°„ë‹¨
**ë‹¨ì **: Redis ì˜ì¡´ì„±, ë„¤íŠ¸ì›Œí¬ ì¥ì•  ìœ„í—˜

```java

@Component
public class RedisDistributedLock {

    @Autowired
    private RedisTemplate<String, String> redisTemplate;

    public boolean tryLock(String key, String value, long expireMs) {
        Boolean result = redisTemplate.opsForValue()
            .setIfAbsent(key, value, Duration.ofMillis(expireMs));
        return Boolean.TRUE.equals(result);
    }

    public void unlock(String key, String value) {
// ìì‹ ì´ ê±´ ë½ì¸ì§€ í™•ì¸ í›„ í•´ì œ
        String script =
            "if redis.call('get', KEYS[1]) == ARGV[1] then " +
            "return redis.call('del', KEYS[1]) " +
            "else return 0 end";
        redisTemplate.execute(new DefaultRedisScript<>(script, Long.class),
            Arrays.asList(key), value);
    }
}

@Service
public class PaymentService {
    public void processPayment(String orderId) {
        String lockKey = "payment:lock:" + orderId;
        String lockValue = UUID.randomUUID().toString();

        if (distributedLock.tryLock(lockKey, lockValue, 30000)) {
            try {
// ê²°ì œ ì²˜ë¦¬ (30ì´ˆ ì•ˆì— ì™„ë£Œ)
                processPaymentInternal(orderId);
            } finally {
                distributedLock.unlock(lockKey, lockValue);
            }
        } else {
            throw new PaymentLockException("ì´ë¯¸ ê²°ì œ ì§„í–‰ ì¤‘");
        }
    }
}

```

### DB ê¸°ë°˜ ë¶„ì‚° ë½

**ì–¸ì œ ì¨?** ì•ˆì •ì„±ì´ ìµœìš°ì„ ì´ê³  Redis ë„ì…ì´ ì–´ë ¤ìš¸ ë•Œ

**ì–´ë–»ê²Œ?** DB í…Œì´ë¸”ì„ ë½ìœ¼ë¡œ ì‚¬ìš©

**íŠ¹ì§•**:

- ë†’ì€ ì•ˆì •ì„±
- íŠ¸ëœì­ì…˜ ë³´ì¥
- ì„±ëŠ¥ì´ ìƒëŒ€ì ìœ¼ë¡œ ëŠë¦¼

**ì¥ì **: ì•ˆì •ì„±, íŠ¸ëœì­ì…˜ê³¼ í†µí•©
**ë‹¨ì **: ì„±ëŠ¥ ë‚®ìŒ, DB ë¶€í•˜

```java

@Entity
@Table(name = "distributed_locks")
public class DistributedLock {
    @Id
    private String lockKey;
    private String owner;
    private LocalDateTime expiresAt;
}

@Service
public class DatabaseDistributedLock {

    @Transactional
    public boolean tryLock(String key, String owner, Duration duration) {
        try {
            DistributedLock lock = new DistributedLock();
            lock.setLockKey(key);
            lock.setOwner(owner);
            lock.setExpiresAt(LocalDateTime.now().plus(duration));

            lockRepository.save(lock);// ìœ ë‹ˆí¬ ì œì•½ìœ¼ë¡œ ì¤‘ë³µ ë°©ì§€
            return true;
        } catch (DataIntegrityViolationException e) {
            return false;// ì´ë¯¸ ë½ ì¡´ì¬
        }
    }

    @Transactional
    public void unlock(String key, String owner) {
        lockRepository.deleteByLockKeyAndOwner(key, owner);
    }
}

```

### íŒŒì¼ ê¸°ë°˜ ë½

**ì–¸ì œ ì¨?** ë‹¨ìˆœí•œ í™˜ê²½ì—ì„œ ì„ì‹œë¡œ ì‚¬ìš©í•  ë•Œ

**ì–´ë–»ê²Œ?** íŒŒì¼ ì‹œìŠ¤í…œì˜ ë½ íŒŒì¼ ì´ìš©

**íŠ¹ì§•**:

- êµ¬í˜„ ê°„ë‹¨
- ì™¸ë¶€ ì˜ì¡´ì„± ì—†ìŒ
- ì•ˆì •ì„± ë¶€ì¡±

**ì¥ì **: ê°„ë‹¨, ì˜ì¡´ì„± ì—†ìŒ
**ë‹¨ì **: ì•ˆì •ì„± ë¶€ì¡±, ìŠ¤ì¼€ì¼ë§ ì–´ë ¤ì›€

```java

public class FileLock {
    private final String lockFilePath;

    public boolean tryLock() {
        try {
            File lockFile = new File(lockFilePath);
            return lockFile.createNewFile();// ì›ìì  ìƒì„±
        } catch (IOException e) {
            return false;
        }
    }

    public void unlock() {
        new File(lockFilePath).delete();
    }
}

```

---

## ğŸ—ï¸ ì• í”Œë¦¬ì¼€ì´ì…˜ ë ˆë²¨ (Application Level)

> ë²”ìœ„: ì•„í‚¤í…ì²˜ ì„¤ê³„ë¡œ ë™ì‹œì„± ë¬¸ì œ íšŒí”¼
> 

### ì´ë²¤íŠ¸ ê¸°ë°˜ ë¹„ë™ê¸° ì²˜ë¦¬

**ì–¸ì œ ì¨?** ì¦‰ì‹œ ì‘ë‹µ í•„ìš”í•˜ê³  ë’¤ì—ì„œ ì²˜ë¦¬í•´ë„ ë  ë•Œ

**ì–´ë–»ê²Œ?** ìš”ì²­ ì ‘ìˆ˜ í›„ ì´ë²¤íŠ¸ë¡œ ë¹„ë™ê¸° ì²˜ë¦¬

**íŠ¹ì§•**:

- ë¹ ë¥¸ ì‘ë‹µ
- ì²˜ë¦¬ ìˆœì„œ ë³´ì¥
- ë³µì¡ì„± ì¦ê°€

**ì¥ì **: ì‚¬ìš©ì ê²½í—˜ í–¥ìƒ, ë¶€í•˜ ë¶„ì‚°
**ë‹¨ì **: ë³µì¡ì„±, ë””ë²„ê¹… ì–´ë ¤ì›€

```java

// ì¦‰ì‹œ ì‘ë‹µ
@PostMapping("/payment")
public ResponseEntity<String> requestPayment(@RequestBody PaymentRequest request) {
    eventPublisher.publishEvent(new PaymentEvent(request));
    return ResponseEntity.ok("ê²°ì œ ìš”ì²­ ì ‘ìˆ˜ì™„ë£Œ!");
}

// ë¹„ë™ê¸° ì²˜ë¦¬
@EventListener
@Async
public void handlePaymentEvent(PaymentEvent event) {
    paymentService.processPayment(event);// ìˆœì°¨ ì²˜ë¦¬ë¡œ ë™ì‹œì„± ë¬¸ì œ ì—†ìŒ
}

```

### ë‹¨ì¼ ìŠ¤ë ˆë“œ + ì‘ì—… í

**ì–¸ì œ ì¨?** ìƒíƒœ ê´€ë¦¬ê°€ ë³µì¡í•˜ê³  ì•ˆì „ì„±ì´ ìµœìš°ì„ ì¼ ë•Œ

**ì–´ë–»ê²Œ?** í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œê°€ íì—ì„œ ìˆœì„œëŒ€ë¡œ ì²˜ë¦¬

**íŠ¹ì§•**:

- ë™ì‹œì„± ë¬¸ì œ ì›ì²œ ì°¨ë‹¨
- ì²˜ë¦¬ëŸ‰ ì œí•œ
- ë‹¨ìˆœí•œ êµ¬ì¡°

**ì¥ì **: ì•ˆì „ì„±, ë””ë²„ê¹… ì‰¬ì›€
**ë‹¨ì **: ì²˜ë¦¬ëŸ‰ ì œí•œ, ë‹¨ì¼ ì¥ì• ì 

```java

@Component
public class OrderProcessor {
    private final BlockingQueue<OrderTask> taskQueue = new LinkedBlockingQueue<>();
    private volatile boolean running = true;

    @PostConstruct
    public void startProcessor() {
        new Thread(this::processOrders).start();
    }

    private void processOrders() {
        while (running) {
            try {
                OrderTask task = taskQueue.poll(1, TimeUnit.SECONDS);
                if (task != null) {
                    task.execute();// ìˆœì°¨ ì²˜ë¦¬
                }
            } catch (InterruptedException e) {
                break;
            }
        }
    }

    public void submitOrder(OrderTask task) {
        taskQueue.offer(task);
    }
}

```

### CQRS íŒ¨í„´

**ì–¸ì œ ì¨?** ì½ê¸°ì™€ ì“°ê¸° íŒ¨í„´ì´ ì™„ì „ ë‹¤ë¥¼ ë•Œ

**ì–´ë–»ê²Œ?** ì½ê¸°ìš© ëª¨ë¸ê³¼ ì“°ê¸°ìš© ëª¨ë¸ ë¶„ë¦¬

**íŠ¹ì§•**:

- ì½ê¸°/ì“°ê¸° ìµœì í™”
- ëª¨ë¸ ë¶„ë¦¬ë¡œ ë³µì¡ì„± ì¦ê°€
- ë°ì´í„° ë™ê¸°í™” í•„ìš”

**ì¥ì **: ì„±ëŠ¥ ìµœì í™”, í™•ì¥ì„±
**ë‹¨ì **: ë³µì¡ì„±, ì¼ê´€ì„± ê´€ë¦¬

```java

// ì“°ê¸° ì „ìš© ì„œë¹„ìŠ¤
@Service
public class OrderCommandService {
    public void createOrder(CreateOrderCommand command) {
        Order order = new Order(command);
        orderRepository.save(order);
// ì½ê¸° ëª¨ë¸ ì—…ë°ì´íŠ¸ ì´ë²¤íŠ¸
        eventPublisher.publish(new OrderCreatedEvent(order));
    }
}

// ì½ê¸° ì „ìš© ì„œë¹„ìŠ¤
@Service
public class OrderQueryService {
    public List<OrderView> getOrders(OrderQuery query) {
        return orderViewRepository.findByQuery(query);
    }
}

```

### ë©”ì‹œì§€ í ì•„í‚¤í…ì²˜

**ì–¸ì œ ì¨?** ë§ˆì´í¬ë¡œì„œë¹„ìŠ¤ ê°„ í†µì‹ , ë¶€í•˜ ë¶„ì‚° í•„ìš”í•  ë•Œ

**ì–´ë–»ê²Œ?** ë©”ì‹œì§€ íë¡œ ì‘ì—… ë¶„ì‚°

**íŠ¹ì§•**:

- ë¹„ë™ê¸° ì²˜ë¦¬
- ì„œë¹„ìŠ¤ ê°„ ê²°í•©ë„ ë‚®ì¶¤
- ë©”ì‹œì§€ ìˆœì„œ ë³´ì¥ ì–´ë ¤ì›€

**ì¥ì **: í™•ì¥ì„±, ë‚´ê²°í•¨ì„±
**ë‹¨ì **: ë³µì¡ì„±, ì§€ì—° ì‹œê°„

```java

// ë©”ì‹œì§€ ë°œí–‰
@Service
public class PaymentPublisher {
    public void requestPayment(PaymentRequest request) {
        PaymentMessage message = new PaymentMessage(request);
        rabbitTemplate.convertAndSend("payment.queue", message);
    }
}

// ë©”ì‹œì§€ ì†Œë¹„
@RabbitListener(queues = "payment.queue")
public void handlePayment(PaymentMessage message) {
    paymentService.process(message);// ìˆœì°¨ ì²˜ë¦¬
}

```

### ìƒíƒœ ë¨¸ì‹  íŒ¨í„´

**ì–¸ì œ ì¨?** ìƒíƒœ ë³€ê²½ì´ ë³µì¡í•˜ê³  ìˆœì„œê°€ ì¤‘ìš”í•  ë•Œ

**ì–´ë–»ê²Œ?** ìƒíƒœ ì „í™˜ ê·œì¹™ìœ¼ë¡œ ë™ì‹œ ë³€ê²½ ë°©ì§€

**íŠ¹ì§•**:

- ìƒíƒœ ë³€ê²½ ê·œì¹™ ëª…í™•
- ë™ì‹œ ë³€ê²½ ë°©ì§€
- ë³µì¡í•œ ìƒíƒœ ê´€ë¦¬

**ì¥ì **: ì•ˆì „í•œ ìƒíƒœ ê´€ë¦¬, ëª…í™•í•œ ê·œì¹™
**ë‹¨ì **: ë³µì¡ì„±, í™•ì¥ì„± ì œí•œ

```java

@Component
public class OrderStateMachine {
    private final Map<StateTransition, OrderState> transitions = Map.of(
        new StateTransition(PENDING, PAY), PAID,
        new StateTransition(PAID, SHIP), SHIPPED,
        new StateTransition(PENDING, CANCEL), CANCELLED
    );

    public synchronized boolean changeState(Order order, OrderEvent event) {
        OrderState currentState = order.getState();
        OrderState nextState = transitions.get(new StateTransition(currentState, event));

        if (nextState != null) {
            order.setState(nextState);
            return true;
        }
        return false;// ì˜ëª»ëœ ìƒíƒœ ì „í™˜
    }
}

```

## ğŸ—„ï¸ DB ë ˆë²¨ (Database Level)

> ë²”ìœ„: ë°ì´í„°ë² ì´ìŠ¤ ìì²´ ê¸°ëŠ¥ìœ¼ë¡œ ë™ì‹œì„± ì œì–´
> 

<aside>
ğŸ’¡

### ë‚™ê´€ì  ë½ vs ë¹„ê´€ì  ë½ (Optimistic Lock vs Pessimistic Lock)

ì„ ì  ë¹„ì„ ì ì´ ë‚˜ì˜¤ë‹ˆê¹Œ ìê¾¸ í—·ê°ˆë¦¼

| ê°œë… | ì ìœ  ë°©ì‹ | ì„ ì /ë¹„ì„ ì  ë¹„ìœ  |
| --- | --- | --- |
| **ë‚™ê´€ì  ë½** | ìì› ì ìœ  ì—†ì´ "ë‚´ê°€ ì„±ê³µí•˜ë©´ ê°€ì ¸ê°ˆê²Œ" â†’ ì‹¤íŒ¨ ì‹œ ì¬ì‹œë„ | **ë¹„ì„ ì  ëŠë‚Œ** (ìì›ì„ ëºëŠ” ê²Œ ì•„ë‹ˆë¼, ì¡°ê±´ ë§ìœ¼ë©´ ê°€ì ¸ê°) |
| **ë¹„ê´€ì  ë½** | ìì›ì„ ë¨¼ì € ë½ìœ¼ë¡œ ë¬¶ê³  "ë‹¤ë¥¸ ë†ˆ ëª» ì¨" â†’ ì ìœ ë¶€í„° í•¨ | **ì„ ì  ëŠë‚Œ** (ë½ ê±¸ì–´ì„œ ë‚¨ ëª» ì˜¤ê²Œ ë§‰ìŒ) |
</aside>

### 1. ë¹„ê´€ì  ë½ (Pessimistic Lock)

**ì–¸ì œ ì¨?** ì¶©ëŒì´ ìì£¼ ì¼ì–´ë‚  ê²ƒ ê°™ì„ ë•Œ

**ì–´ë–»ê²Œ?** ë°ì´í„° ì¡°íšŒ ì‹œ ì¦‰ì‹œ ë½ íšë“

**íŠ¹ì§•**:

- ì¦‰ì‹œ ë½ íšë“
- íŠ¸ëœì­ì…˜ ì¢…ë£Œê¹Œì§€ ìœ ì§€
- ëŒ€ê¸° ì‹œê°„ ë°œìƒ

**ì¥ì **: í™•ì‹¤í•œ ë™ì‹œì„± ì œì–´
**ë‹¨ì **: ì„±ëŠ¥ ì €í•˜, ë°ë“œë½ ìœ„í—˜

```java

@Repository
public interface AccountRepository extends JpaRepository<Account, Long> {
    @Lock(LockModeType.PESSIMISTIC_WRITE)
    @Query("SELECT a FROM Account a WHERE a.id = :id")
    Account findByIdForUpdate(@Param("id") Long id);
}

@Service
@Transactional
public class TransferService {
    public void transfer(Long fromId, Long toId, BigDecimal amount) {
// ë°ë“œë½ ë°©ì§€ë¥¼ ìœ„í•´ ID ìˆœì„œë¡œ ë½ íšë“
        Long firstId = Math.min(fromId, toId);
        Long secondId = Math.max(fromId, toId);

        Account first = accountRepository.findByIdForUpdate(firstId);
        Account second = accountRepository.findByIdForUpdate(secondId);

        Account from = fromId.equals(firstId) ? first : second;
        Account to = fromId.equals(firstId) ? second : first;

        from.withdraw(amount);
        to.deposit(amount);
    }
}

```

### 2. ë‚™ê´€ì  ë½ (Optimistic Lock)

**ì–¸ì œ ì¨?** ì¶©ëŒì´ ë³„ë¡œ ì•ˆ ì¼ì–´ë‚  ê²ƒ ê°™ì„ ë•Œ

**ì–´ë–»ê²Œ?** ë²„ì „ ë²ˆí˜¸ë¡œ ì¶©ëŒ ê°ì§€

**íŠ¹ì§•**:

- ëŒ€ê¸° ì‹œê°„ ì—†ìŒ
- ì¶©ëŒ ì‹œ ì¬ì‹œë„ í•„ìš”
- ë²„ì „ ê´€ë¦¬ í•„ìš”

**ì¥ì **: ì„±ëŠ¥ ì¢‹ìŒ, ë¹ ë¥¸ ì‘ë‹µ
**ë‹¨ì **: ì¶©ëŒ ì‹œ ì¬ì²˜ë¦¬ í•„ìš”

```java

@Entity
public class Account {
    @Id
    private Long id;

    @Version
    private Long version;// JPAê°€ ìë™ ê´€ë¦¬

    private BigDecimal balance;

    public void withdraw(BigDecimal amount) {
        if (balance.compareTo(amount) < 0) {
            throw new InsufficientBalanceException();
        }
        this.balance = balance.subtract(amount);
    }
}

@Service
@Transactional
public class AccountService {
    @Retryable(value = OptimisticLockingFailureException.class, maxAttempts = 3)
    public void withdraw(Long accountId, BigDecimal amount) {
        Account account = accountRepository.findById(accountId)
            .orElseThrow(() -> new AccountNotFoundException());

        account.withdraw(amount);
        accountRepository.save(account);// ë²„ì „ ì²´í¬ ë° ì¦ê°€
    }
}

```

### 3. ì¦ë¶„ ì¿¼ë¦¬ (Atomic Update)

**ì–¸ì œ ì¨?** ë‹¨ìˆœí•œ ì¹´ìš´í„° ì¦ê°í•  ë•Œ

**ì–´ë–»ê²Œ?** DBì˜ ì›ìì  ì—°ì‚° í™œìš©

**íŠ¹ì§•**:

- ë½ ì—†ì´ ì•ˆì „
- ë‹¨ìˆœí•œ ì—°ì‚°ë§Œ ê°€ëŠ¥
- ë†’ì€ ì„±ëŠ¥

**ì¥ì **: ì„±ëŠ¥ ì¢‹ìŒ, ë½ ë¶ˆí•„ìš”
**ë‹¨ì **: ë‹¨ìˆœ ì—°ì‚°ë§Œ ê°€ëŠ¥

```java

@Repository
public interface PostRepository extends JpaRepository<Post, Long> {
    @Modifying
    @Query("UPDATE Post p SET p.viewCount = p.viewCount + 1 WHERE p.id = :id")
    int incrementViewCount(@Param("id") Long id);

    @Modifying
    @Query("UPDATE Post p SET p.likeCount = p.likeCount + :delta WHERE p.id = :id")
    int updateLikeCount(@Param("id") Long id, @Param("delta") int delta);
}

@Service
@Transactional
public class PostService {
    public void viewPost(Long postId) {
        int updated = postRepository.incrementViewCount(postId);
        if (updated == 0) {
            throw new PostNotFoundException();
        }
    }
}

```

### 4. íŠ¸ëœì­ì…˜ ê²©ë¦¬ ìˆ˜ì¤€

**ì–¸ì œ ì¨?** ë°ì´í„° ì¼ê´€ì„± ìˆ˜ì¤€ì„ ì¡°ì ˆí•  ë•Œ

**ì–´ë–»ê²Œ?** ê²©ë¦¬ ìˆ˜ì¤€ ì„¤ì •

**íŠ¹ì§•**:

- 4ë‹¨ê³„ ê²©ë¦¬ ìˆ˜ì¤€
- ì„±ëŠ¥ê³¼ ì¼ê´€ì„± íŠ¸ë ˆì´ë“œì˜¤í”„
- DBë³„ êµ¬í˜„ ì°¨ì´

**ì¥ì **: ì„¸ë°€í•œ ì œì–´
**ë‹¨ì **: ë³µì¡ì„±, ì„±ëŠ¥ ì˜í–¥

```java

@Service
public class OrderService {

// ê¸°ë³¸ - ì»¤ë°‹ëœ ë°ì´í„°ë§Œ ì½ê¸°
    @Transactional(isolation = Isolation.READ_COMMITTED)
    public Order getOrder(Long orderId) {
        return orderRepository.findById(orderId).orElse(null);
    }

// ë°˜ë³µ ì½ê¸° ë³´ì¥
    @Transactional(isolation = Isolation.REPEATABLE_READ)
    public void processOrder(Long orderId) {
        Order order1 = orderRepository.findById(orderId).orElse(null);
// ë‹¤ë¥¸ ë¡œì§ë“¤...
        Order order2 = orderRepository.findById(orderId).orElse(null);
// order1ê³¼ order2ëŠ” ê°™ì€ ë°ì´í„° ë³´ì¥
    }

// ìµœê³  ìˆ˜ì¤€ ê²©ë¦¬ (ì„±ëŠ¥ ì €í•˜)
    @Transactional(isolation = Isolation.SERIALIZABLE)
    public void criticalOperation(Long orderId) {
// ì™„ì „í•œ ê²©ë¦¬ ë³´ì¥
    }
}

```
