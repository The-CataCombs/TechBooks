<aside>
ğŸ’¡

### ë¹„ë™ê¸°(Asynchronous)ë‘ ë…¼ë¸”ë¡œí‚¹(Non-blocking)ì´ ì™„ì „ ë³„ê°œì˜ ê°œë…~

**ë¹„ë™ê¸° vs ë™ê¸°**ëŠ” **ê²°ê³¼ë¥¼ ì–¸ì œ ì–´ë–»ê²Œ ë°›ì„ ê²ƒì¸ê°€**

- **ë™ê¸°**: ì‘ì—…ì„ ìš”ì²­í•˜ê³  ê²°ê³¼ë¥¼ ë°›ì„ ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¼
- **ë¹„ë™ê¸°**: ì‘ì—…ì„ ìš”ì²­í•˜ê³  ê²°ê³¼ëŠ” ë‚˜ì¤‘ì— ì½œë°±/ì´ë²¤íŠ¸ë¡œ ë°›ìŒ

**ë¸”ë¡œí‚¹ vs ë…¼ë¸”ë¡œí‚¹**ì€ **í•¨ìˆ˜ë¥¼ í˜¸ì¶œí–ˆì„ ë•Œ ì œì–´ê¶Œì„ ì–¸ì œ ëŒë ¤ë°›ì„ ê²ƒì¸ê°€**

- **ë¸”ë¡œí‚¹**: ì‘ì—…ì´ ì™„ë£Œë  ë•Œê¹Œì§€ ì œì–´ê¶Œì„ ì•ˆ ëŒë ¤ì¤Œ
- **ë…¼ë¸”ë¡œí‚¹**: ì‘ì—… ì™„ë£Œ ì—¬ë¶€ì™€ ìƒê´€ì—†ì´ ì¦‰ì‹œ ì œì–´ê¶Œì„ ëŒë ¤ì¤Œ

ì•„ë˜ 4ê°€ì§€ ì¡°í•©ì´ ê°€ëŠ¥~

- **ë™ê¸° + ë¸”ë¡œí‚¹**: ì¼ë°˜ì ì¸ í•¨ìˆ˜ í˜¸ì¶œ (ê²°ê³¼ ë°›ì„ ë•Œê¹Œì§€ ëŒ€ê¸°)(Node.jsì˜ fs.readFileSync())
- **ë™ê¸° + ë…¼ë¸”ë¡œí‚¹**: í´ë§ ë°©ì‹ (ê³„ì† í™•ì¸í•˜ë©´ì„œ ê¸°ë‹¤ë¦¼)
- **ë¹„ë™ê¸° + ë¸”ë¡œí‚¹**: ì˜ ì•ˆ ì“°ì´ëŠ” íŒ¨í„´ (select() í•¨ìˆ˜ ê°™ì€ ê²½ìš°)
- **ë¹„ë™ê¸° + ë…¼ë¸”ë¡œí‚¹**: ì´ë²¤íŠ¸ ë£¨í”„, Promise/async-await ê°™ì€ í˜„ëŒ€ì  ë°©ì‹(
 Node.jsì˜ `fs.readFile()`, JSì˜ `setTimeout`ë„)

### ì‰½ê²Œ ì´í•´í•´ë³´ì~

**ë™ê¸°+ë¸”ë¡œí‚¹**

- ìŒì‹ì ì—ì„œ ì£¼ë¬¸í•˜ê³  ìŒì‹ì´ ë‚˜ì˜¬ ë•Œê¹Œì§€ ì¹´ìš´í„° ì•ì—ì„œ ê¼¼ì§ ì•ˆ í•˜ê³  ê¸°ë‹¤ë¦¬ëŠ” ìƒí™©.
- ìŒì‹ì´ ì™„ì„±ë˜ë©´ ì§ì ‘ ë°›ì•„ì„œ ìë¦¬ë¡œ ê°. ê¸°ë‹¤ë¦¬ëŠ” ë™ì•ˆ ì•„ë¬´ê²ƒë„ ëª»í•¨

**ë¹„ë™ê¸°+ë…¼ë¸”ë¡œí‚¹**

- ìŒì‹ì ì—ì„œ ì£¼ë¬¸í•˜ê³  ì§„ë™ë²¨ì„ ë°›ì•„ì„œ ìë¦¬ì— ì•‰ì•„ ìˆë‹¤ê°€, ë²¨ì´ ìš¸ë¦¬ë©´ ê°€ì„œ ìŒì‹ì„ ê°€ì ¸ì˜¤ëŠ” ë°©ì‹.
- ê¸°ë‹¤ë¦¬ëŠ” ë™ì•ˆ ì¹œêµ¬ì™€ ëŒ€í™”ë„ í•˜ê³  í°ë„ ë³´ê³  ë‹¤ë¥¸ ì¼ì„ í•  ìˆ˜ ìˆì–´ì„œ íš¨ìœ¨ì 

**ë™ê¸°+ë…¼ë¸”ë¡œí‚¹**

- ìŒì‹ì ì—ì„œ ì£¼ë¬¸í•˜ê³  ë§¤ 1ë¶„ë§ˆë‹¤ ì¹´ìš´í„°ì— ê°€ì„œ "ì œ ìŒì‹ ë‚˜ì™”ë‚˜ìš”?"ë¼ê³  ê³„ì† ë¬¼ì–´ë³´ëŠ” ê²ƒì„
- ì¹´ìš´í„° ì§ì›ì€ ë°”ë¡œ "ì•„ì§ìš”" ë˜ëŠ” "ë‚˜ì™”ì–´ìš”"ë¼ê³  ë‹µí•´ì¤Œ
- ì†ë‹˜ì€ ìŒì‹ì´ ì™„ì„±ë  ë•Œê¹Œì§€ ê³„ì† í™•ì¸í•˜ëŸ¬ ê°€ì•¼ í•¨
- ë¹„íš¨ìœ¨ì ì´ì§€ë§Œ ê°€ë” í•„ìš”í•œ ê²½ìš°ê°€ ìˆë‹¤(í´ë§)

**ë¹„ë™ê¸°+ë¸”ë¡œí‚¹**

- ì—¬ëŸ¬ ìŒì‹ì ì— ë™ì‹œì— ì£¼ë¬¸ì„ ë„£ê³  ì–´ëŠ ê³³ì´ë“  ë¨¼ì € ì™„ì„±ë˜ëŠ” ê³³ ì•ì—ì„œ ê¸°ë‹¤ë¦¬ëŠ” ìƒí™©
- í•˜ë‚˜ë¼ë„ ì™„ì„±ë˜ë©´ ê·¸ë•Œë¶€í„° ì—¬ëŸ¬ ì£¼ë¬¸ì„ ë™ì‹œì— ì²˜ë¦¬í•˜ê¸° ì‹œì‘

1. **í”¼ìì§‘, ì¹˜í‚¨ì§‘, ì¤‘êµ­ì§‘ì— ë™ì‹œ ì£¼ë¬¸** (ë¹„ë™ê¸° ì‹œì‘)
2. **í”¼ìì§‘ ì•ì—ì„œë§Œ ì„œì„œ ê¸°ë‹¤ë¦¼** (ë¸”ë¡œí‚¹)
3. **í”¼ì ë°›ìœ¼ë©´ ê·¸ì œì„œì•¼ ì¹˜í‚¨ì§‘, ì¤‘êµ­ì§‘ ê°€ì„œ ë°›ê¸°**
</aside>

<aside>
ğŸ§

### ë¹„ë™ê¸°+ë¸”ë¡œí‚¹ì„â€¦ ëŒ€ì²´ ì™œ í•˜ëŠ”ê±´ë°..?

## ì§„ì§œâ€¦ì–¸ì œ ì“°ëŠ”ê±´ë°..?

â‡’ ë‹¤ë¥¸ê±´ ì´í•´ê°€ ê°€ëŠ”ë° ë¹„ë™ê¸° ë¸”ë¡œí‚¹ì€ ì–¸ì œ ì™œ ì“°ëŠ”ì§€ ì´í•´ê°€ ì•ˆ ê°€ì„œ ì¢€ ë” ì°¾ì•„ë´„

`select()`: Unix/Linux ì‹œìŠ¤í…œì—ì„œ ì œê³µí•˜ëŠ” **ë‹¤ì¤‘ ì…ì¶œë ¥ ë‹¤ì¤‘í™”(I/O multiplexing)** ì‹œìŠ¤í…œ ì½œ

ì—¬ëŸ¬ ê°œì˜ íŒŒì¼ ë””ìŠ¤í¬ë¦½í„°(ì†Œì¼“, íŒŒì¼ ë“±)ë¥¼ ë™ì‹œì— ëª¨ë‹ˆí„°ë§í•˜ë‹¤ê°€, ê·¸ ì¤‘ í•˜ë‚˜ë¼ë„ ì½ê¸°/ì“°ê¸°ê°€ ê°€ëŠ¥í•´ì§€ë©´ ì•Œë ¤ì£¼ëŠ” í•¨ìˆ˜

ì„œë²„ê°€ 1000ê°œì˜ í´ë¼ì´ì–¸íŠ¸ì™€ ì—°ê²°ë˜ì–´ ìˆì„ ë•Œ ê°ê°ì„ ìœ„í•´ 1000ê°œì˜ ìŠ¤ë ˆë“œë¥¼ ë§Œë“¤ë©´ ë©”ëª¨ë¦¬ë„ ë§ì´ ì“°ê³  ì„±ëŠ¥ë„ ë–¨ì–´ì ¸ì„œ í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œë¡œ ì—¬ëŸ¬ ì—°ê²°ì„ ê´€ë¦¬í•˜ëŠ” ë°©ë²•ì´ë¼ê³  í•¨

## ğŸ¤” ì™œ ì´ëŸ° ì´ìƒí•œ ì¡°í•©ì„?

### ì˜ëª»ëœ í•´ê²°ë²•ë“¤

**1. ë™ê¸°+ë¸”ë¡œí‚¹ (ìˆœì°¨ ì²˜ë¦¬)**

```c

for(int i = 0; i < 1000; i++) {
    read(client[i]);// ì²« ë²ˆì§¸ê°€ ì•ˆ ì˜¤ë©´ ë‚˜ë¨¸ì§€ 999ê°œ ëŒ€ê¸°
}

```

â†’ ì²« ë²ˆì§¸ í´ë¼ì´ì–¸íŠ¸ê°€ ì‘ë‹µ ì•ˆ í•˜ë©´ ëª¨ë“  ê²Œ ë©ˆì¶¤

1. **ë™ê¸° + ë…¼ë¸”ë¡œí‚¹** (í´ë§ ì§€ì˜¥)

```java
// ì´ê²ƒë„ ë¹„íš¨ìœ¨ì 
while(1) {
    for(int i = 0; i < 1000; i++) {
        int result = read(client_fd[i], buffer, 1024); // ì¦‰ì‹œ ë¦¬í„´
        if(result == -1 && errno == EAGAIN) {
            continue; // ë°ì´í„° ì—†ìŒ, ë‹¤ìŒìœ¼ë¡œ
        }
        // ë°ì´í„° ì²˜ë¦¬
    }
}
```

1. **ë¹„ë™ê¸° + ë…¼ë¸”ë¡œí‚¹** (ì½œë°± ì§€ì˜¥)

```java
// ê°ê°ì— ì½œë°± ë“±ë¡
for(int i = 0; i < 1000; i++) {
    aio_read(&aiocb[i]); // ê°ê° ë¹„ë™ê¸° ì½ê¸° ì‹œì‘
}
```

**4. ìŠ¤ë ˆë“œ 1000ê°œ**

```c

for(int i = 0; i < 1000; i++) {
    pthread_create(&thread[i], NULL, handle_client, &client[i]);
}

```

â†’ ë©”ëª¨ë¦¬ í­ë°œ â‡’ die (ìŠ¤ë ˆë“œë‹¹ ~8MB)

### ë¹„ë™ê¸°+ë¸”ë¡œí‚¹ = ì²œêµ­ â‡’ select()ì˜ í•´ê²°ë²•

```c
while(1) {
    FD_ZERO(&readfds);
    for(int i = 0; i < 1000; i++) {
        FD_SET(client[i], &readfds);// 1000ê°œ ë“±ë¡
    }

// ì´ í•œ ì¤„ë¡œ 1000ê°œë¥¼ ë™ì‹œì— ëª¨ë‹ˆí„°ë§í•˜ë‹¤ê°€
// í•˜ë‚˜ë¼ë„ ë°ì´í„° ì˜¤ë©´ ê¹¨ì–´ë‚¨
    select(max_fd + 1, &readfds, NULL, NULL, NULL);

// ì¤€ë¹„ëœ ê²ƒë“¤ë§Œ ì²˜ë¦¬
    for(int i = 0; i < 1000; i++) {
        if(FD_ISSET(client[i], &readfds)) {
            handle_client(client[i]);// ì¤€ë¹„ëœ ê²ƒë§Œ ì²˜ë¦¬
        }
    }
}

```

## ğŸ’¡ ì™œ ì´ë ‡ê²Œ í•´ì•¼ë§Œ í–ˆëŠ”ê°€~

**ë¦¬ì†ŒìŠ¤ íš¨ìœ¨ì„±**

- ìŠ¤ë ˆë“œ 1ê°œë¡œ 1000ê°œ ì—°ê²° ê´€ë¦¬
- ë©”ëª¨ë¦¬: 8GB â†’ 8MBë¡œ ì ˆì•½
- CPU: ì»¨í…ìŠ¤íŠ¸ ìŠ¤ìœ„ì¹­ ìµœì†Œí™”

**ì‹¤ì‹œê°„ ë°˜ì‘ì„±**

- ì–´ëŠ í´ë¼ì´ì–¸íŠ¸ë“  ë°ì´í„° ì˜¤ë©´ ì¦‰ì‹œ ì²˜ë¦¬
- ìˆœì„œ ìƒê´€ì—†ì´ ì¤€ë¹„ëœ ê²ƒë¶€í„° ì²˜ë¦¬

### **ë¹„ë™ê¸° ë¶€ë¶„**

- 1000ê°œ íŒŒì¼ ë””ìŠ¤í¬ë¦½í„°ë¥¼ **ë™ì‹œì— ëª¨ë‹ˆí„°ë§**
- ì–´ë–¤ ìˆœì„œë¡œ ë°ì´í„°ê°€ ì™€ë„ ìƒê´€ì—†ìŒ
- ì¤€ë¹„ëœ ê²ƒë“¤ì„ **ë³‘ë ¬ì ìœ¼ë¡œ ì²˜ë¦¬**

### **ë¸”ë¡œí‚¹ ë¶€ë¶„**

- `select()` í•œ ë²ˆìœ¼ë¡œ **íš¨ìœ¨ì  ëŒ€ê¸°**
- CPU ë‚­ë¹„ ì—†ìŒ (í´ë§ ì•ˆ í•¨)
- **í•˜ë‚˜ë¼ë„ ì¤€ë¹„ë˜ë©´ ì¦‰ì‹œ ê¹¨ì–´ë‚¨**

## ì˜ˆì „ì— ë³¸ ì˜ˆì‹œ

ë¦¬ì•¡íŠ¸ Promiseë„ ëª¨ë¥´ë˜ ì‹œì ˆ ê³µë¶€ë¥¼ í–ˆì—ˆì£ .. 

ê·¸ëŸ¬ë‹¤ ë³´ê²Œëœ Promise.allì´ ê¸°ì–µì´ ë‚˜ë„¤ìš”â€¦

React + Promise.all : ë³‘ë ¬ ë¹„ë™ê¸° ì²˜ë¦¬

```jsx
import React, { useEffect, useState } from 'react';

function DataFetcher() {
  const [data, setData] = useState([]);

  useEffect(() => {
    async function fetchData() {
      const urls = [
        'https://www.minisundev.com/posts/1',
        'https://www.minisundev.com/posts/2',
        'https://www.minisundev.com/posts/3',
      ];

      try {
        // ë³‘ë ¬ë¡œ ë™ì‹œì— ìš”ì²­ ë³´ë‚´ê³ , ëª¨ë‘ ëë‚  ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¼ (selectì²˜ëŸ¼)
        const responses = await Promise.all(urls.map(url => fetch(url)));
        const results = await Promise.all(responses.map(res => res.json()));
        setData(results); // ìˆœì„œëŒ€ë¡œ ì²˜ë¦¬
      } catch (err) {
        console.error('Error fetching:', err);
      }
    }

    fetchData();
  }, []);

  return (
    <div>
      <h1>Fetched Data</h1>
      <ul>
        {data.map(d => (
          <li key={d.id}>{d.title}</li>
        ))}
      </ul>
    </div>
  );
}

```

ë‘˜ì˜ ìƒí™©ì´ ë¹„ìŠ·í•˜ë‹¤~~ ì´ëŸ´ë•Œ ì‚¬ìš©í•œë‹¤~~

| C/Linux select | React + Promise.all |
| --- | --- |
| `select()`ë¡œ ì—¬ëŸ¬ ì†Œì¼“ì„ **ë™ì‹œì— ëª¨ë‹ˆí„°ë§** | `Promise.all()`ë¡œ ì—¬ëŸ¬ ìš”ì²­ì„ **ë™ì‹œì— ëŒ€ê¸°** |
| ë°ì´í„°ê°€ **ë„ì°©í•˜ë©´ ë¸”ë¡œí‚¹ í’€ë¦¼** | ëª¨ë“  fetchê°€ **resolveë˜ë©´ ì´í›„ ë¡œì§ ì‹¤í–‰** |
| ë¶ˆí•„ìš”í•œ ë¦¬ì†ŒìŠ¤ ë‚­ë¹„ ì—†ìŒ | fetchë“¤ì„ ìˆœì°¨ì ìœ¼ë¡œ ê¸°ë‹¤ë¦¬ì§€ ì•Šê³  **ë³‘ë ¬ ì²˜ë¦¬** |
| í´ë¼ì´ì–¸íŠ¸ ì¤‘ **ì¤€ë¹„ëœ ê²ƒë§Œ ì²˜ë¦¬** | ì‘ë‹µëœ ê²ƒë“¤ì„ í•œ ë²ˆì— ëª¨ì•„ì„œ ì²˜ë¦¬ |

### ğŸ”„ **ë¹„ë™ê¸° (Asynchronous)**

- ìš”ì²­ì„ ë³´ëƒˆì§€ë§Œ, **ê·¸ ê²°ê³¼ë¥¼ ê¸°ë‹¤ë¦¬ì§€ ì•Šê³  ë‹¤ìŒ ì‘ì—…ì„ ì§„í–‰**í•  ìˆ˜ ìˆìŒ.
- ëŒ€í‘œ ì˜ˆ: `fetch()`, `setTimeout()`

### ğŸ›‘ **ë¸”ë¡œí‚¹ (Blockingì²˜ëŸ¼ ë³´ì´ëŠ” `await`)**

- `await`ëŠ” **ê·¸ ìë¦¬ì—ì„œ ë©ˆì¶°ì„œ ê²°ê³¼ë¥¼ ê¸°ë‹¤ë¦¬ëŠ” ê²ƒì²˜ëŸ¼ ë³´ì„**.
- í•˜ì§€ë§Œ **ì‹¤ì œë¡œëŠ” JS ì—”ì§„ì´ ë©ˆì¶”ëŠ” ê²Œ ì•„ë‹ˆë¼, ê·¸ í•¨ìˆ˜ì˜ ë‚˜ë¨¸ì§€ ì½”ë“œ ì‹¤í–‰ì„ ë¯¸ë¤„ë‘ **.
- ì¦‰, **ë‹¤ë¥¸ ì´ë²¤íŠ¸ ë£¨í”„ëŠ” ê·¸ëŒ€ë¡œ ëˆë‹¤.**

```jsx
await êµ¬ë¬¸	ì‹¤í–‰ ë©ˆì¶˜ ë“¯ ë³´ì´ë‚˜ â†’ ì‹¤ì œë¡œëŠ” ë’¤ ë¡œì§ì´ Microtask Queueì— ëŒ€ê¸°
ê·¸ ë™ì•ˆ	UI ë°˜ì‘ì„± ì‚´ì•„ìˆìŒ / ë‹¤ë¥¸ ì½”ë“œë„ ì‹¤í–‰ë¨
ì´ë²¤íŠ¸ ë£¨í”„	ì½œ ìŠ¤íƒ ë¹„ë©´ Microtask â†’ Task ìˆœìœ¼ë¡œ í•˜ë‚˜ì”© ì‹¤í–‰

ë¦¬ì•¡íŠ¸ëŠ” ë‹¨ì¼ìŠ¤ë ˆë“œì´ë‹¤~~ ë¹„ë™ê¸°ë¡œ ì´ê±°ì €ê±° ìˆœì„œ ë°”ê¿”ê°€ë©´ì„œ í•  ë¿ì„...
```

</aside>

<aside>
ğŸ§

### ì‚¬ì‹¤â€¦ ë™ê¸°+ë…¼ë¸”ë¡œí‚¹ë„ ë” ì°¾ì•„ë´„

í´ë§ ë°©ì‹ìœ¼ë¡œ ì•Œë¦¼ êµ¬í˜„ì´ ê°€ëŠ¥í•œê±¸ ì•Œê³ ìˆì–´ì„œ ëŒ€ì¶© ê·¸ëŸ°ì‹ì´ê³  ë¹„íš¨ìœ¨ì ì´êµ°~ 

í•˜ê³  ë„˜ì–´ê°”ëŠ”ë° 

ì–˜ë„ ë¹„ë™ê¸°+ë¸”ë¡œí‚¹ì˜ select()ì²˜ëŸ¼ ì´ê²Œ ìµœì ì¸ ì‚¬ë¡€ë„ ìˆì„ìˆ˜ê°€ ìˆì–ì•„?

ì˜ˆì‹œë¥¼ ì‚´í´ë³´ë©´ ì ˆëŒ€ ëŠê¸°ë©´ ì•ˆ ë˜ëŠ” ìƒíƒœì¼ë•Œ ì“°ëŠ”ê±°ê°™ë‹¤

- **ì‹¤ì‹œê°„ì„±ì´ ì¤‘ìš”í•œ** ì• í”Œë¦¬ì¼€ì´ì…˜
- **ë©”ì¸ ë£¨í”„ê°€ ë©ˆì¶”ë©´ ì•ˆ ë˜ëŠ”** ì‹œìŠ¤í…œ
- **í´ë§í•˜ë˜ ë¸”ë¡œí‚¹í•˜ê³  ì‹¶ì§€ ì•Šì€** ìƒí™©

### ê²Œì„/ì‹¤ì‹œê°„ ì• í”Œë¦¬ì¼€ì´ì…˜ - í”„ë ˆì„ ë“œë ë°©ì§€

```java
// ê²Œì„ ë©”ì¸ ë£¨í”„
while(game_running) {
    // ë„¤íŠ¸ì›Œí¬ ë°ì´í„° í™•ì¸ (ë…¼ë¸”ë¡œí‚¹)
    int result = recv(network_socket, buffer, 1024, MSG_DONTWAIT);
    
    if(result > 0) {
        // ë°ì´í„° ìˆìœ¼ë©´ ì²˜ë¦¬
        process_network_data(buffer);
    } else if(result == -1 && errno == EAGAIN) {
        // ë°ì´í„° ì—†ìŒ - ê´œì°®ìŒ, ê²Œì„ ê³„ì†
    }
    
    // ê²Œì„ ë¡œì§ì€ í•­ìƒ ì‹¤í–‰ (60fps ìœ ì§€)
    update_game_logic();
    render_frame();
    
    sleep_until_next_frame(); // 16.67ms
}
```

í”„ë ˆì„ ì§„ì§œì§„ì§œ ì¤‘ìš”í•˜ì§€â€¦

- ê²Œì„ì€ **60fpsë¥¼ ìœ ì§€**í•´ì•¼ í•¨(í”„ë ˆì„ì´ ê³§ ì—ì„ì´ê³  í‹°ì–´ ìì)
- ë„¤íŠ¸ì›Œí¬ ë°ì´í„° ê¸°ë‹¤ë¦¬ë‹¤ê°€ **í”„ë ˆì„ ë“œë**í•˜ë©´ ì•ˆ ë¨
- ë°ì´í„° ìˆìœ¼ë©´ ì²˜ë¦¬í•˜ê³ , ì—†ìœ¼ë©´ ë¬´ì‹œí•˜ê³  ê²Œì„ ì§„í–‰

### UI ì• í”Œë¦¬ì¼€ì´ì…˜ - ë°˜ì‘ì„± ìœ ì§€

```jsx
// ì±„íŒ… ì•±ì—ì„œ ë©”ì‹œì§€ í™•ì¸
function updateUI() {
    // ìƒˆ ë©”ì‹œì§€ í™•ì¸ (ë…¼ë¸”ë¡œí‚¹)
    fetch('/api/messages', { 
        signal: AbortSignal.timeout(0) // ì¦‰ì‹œ íƒ€ì„ì•„ì›ƒ
    })
    .then(response => {
        if(response.ok) {
            // ìƒˆ ë©”ì‹œì§€ ìˆìœ¼ë©´ UI ì—…ë°ì´íŠ¸
            updateMessageList(response.data);
        }
    })
    .catch(error => {
        // íƒ€ì„ì•„ì›ƒì´ë‚˜ ì—ëŸ¬ - ë¬´ì‹œí•˜ê³  ì§„í–‰
    });
    
    // UIëŠ” í•­ìƒ ë°˜ì‘í•´ì•¼ í•¨
    handleUserInput();
    updateAnimations();
    
    requestAnimationFrame(updateUI); // ë‹¤ìŒ í”„ë ˆì„
}
```

ê²Œì„ í”„ë ˆì„ ë“œëì´ë‘ ë¹„ìŠ·í•œ ì˜ë¯¸ê°™ê¸°ë„â€¦

### ë©€í‹°ë¯¸ë””ì–´ ì²˜ë¦¬ - ë²„í¼ ê´€ë¦¬

```c
// ì˜¤ë””ì˜¤ ìŠ¤íŠ¸ë¦¬ë°
while(playing) {
    // ë„¤íŠ¸ì›Œí¬ ë²„í¼ í™•ì¸ (ë…¼ë¸”ë¡œí‚¹)
    int bytes = recv(stream_socket, audio_buffer, BUFFER_SIZE, MSG_DONTWAIT);
    
    if(bytes > 0) {
        // ìƒˆ ì˜¤ë””ì˜¤ ë°ì´í„° ì¶”ê°€
        add_to_playback_buffer(audio_buffer, bytes);
    }
    
    // ì˜¤ë””ì˜¤ëŠ” ëŠê¸°ë©´ ì•ˆ ë¨ - ê¸°ì¡´ ë²„í¼ë¡œ ì¬ìƒ ê³„ì†
    play_current_buffer();
    
    usleep(1000); // 1ms
}
```

</aside>

### **ì„œë²„ê°€ ë™ì‹œì— ìš”ì²­ì²˜ë¦¬í•˜ëŠ” ë°©ë²•**

í´ë¼ì´ì–¸íŠ¸ ìš”ì²­ë§ˆë‹¤ ìŠ¤ë ˆë“œë¥¼ í• ë‹¹ â‡’ ìŠ¤í”„ë§ ë””í´íŠ¸

ë¹„ë™ê¸° IO(í˜¹ì€ ë…¼ë¸”ë¡œí‚¹ IO) â‡’ ë¦¬ì•¡íŠ¸ ë””í´íŠ¸

1. ë©€í‹°ìŠ¤ë ˆë“œ ë°©ì‹ â†’ ìŠ¤í”„ë§ ê¸°ë³¸ê°’
    - ìš”ì²­ë§ˆë‹¤ ìŠ¤ë ˆë“œ í• ë‹¹
    - Thread Pool ì‚¬ìš©
2. ì´ë²¤íŠ¸ ë£¨í”„ + ë¹„ë™ê¸° IO â†’ React.js, Node.js ê¸°ë³¸ê°’
    - ë‹¨ì¼ ìŠ¤ë ˆë“œ + ë…¼ë¸”ë¡œí‚¹ IO
    - ì½œë°±/Promise ê¸°ë°˜

## ì»¤ìŠ¤í…€ë„ ê°€ëŠ¥í•˜ë‹¤~

Atomic ì—°ì‚°ì„ CASë§ê³ ë„ ì•Œì•„ë³´ì~

### Hardware Atomic ì—°ì‚°ë“¤

**CPUê°€ í•˜ë“œì›¨ì–´ ë ˆë²¨ì—ì„œ ì›ìì ìœ¼ë¡œ ìˆ˜í–‰**í•˜ëŠ” ì—°ì‚°

ìš´ì˜ì²´ì œë‚˜ ì†Œí”„íŠ¸ì›¨ì–´ì˜ ê°œì… ì—†ì´ **ë‹¨ì¼ ëª…ë ¹ì–´ë¡œ ì™„ë£Œ**ë˜ì–´ ì¤‘ê°„ì— ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ë¼ì–´ë“¤ ìˆ˜ ì—†ìŒ

## Compare-And-Swap (CAS)

ëª¨ë“  Lock-free ì•Œê³ ë¦¬ì¦˜ì˜ ê¸°ë°˜

```java

// CAS ì˜ì‚¬ì½”ë“œ
boolean compareAndSwap(int* ptr, int expected, int new_value) {
    if (*ptr == expected) {
        *ptr = new_value;
        return true;// ì„±ê³µ
    }
    return false;// ì‹¤íŒ¨
}

// Javaì—ì„œ CAS ì‚¬ìš©
AtomicInteger counter = new AtomicInteger(5);
boolean success = counter.compareAndSet(5, 10);// 5ë©´ 10ìœ¼ë¡œ ë³€ê²½

```

**CASì˜ ABA ë¬¸ì œì™€ í•´ê²°ì±…**

```java

// ABA ë¬¸ì œ: A â†’ B â†’ Aë¡œ ë³€ê²½ë˜ì—ˆëŠ”ë° ê°ì§€í•˜ì§€ ëª»í•¨
AtomicStampedReference<String> ref = new AtomicStampedReference<>("A", 0);

// ìŠ¤íƒ¬í”„(ë²„ì „)ë„ í•¨ê»˜ í™•ì¸
int stamp = ref.getStamp();
ref.compareAndSet("A", "C", stamp, stamp + 1);

```

â‡’ CAS ë²„ì €ë‹ì„â€¦ gc ê³µë¶€í•˜ë‹¤ ë³´ì•˜ì—ˆì§€! ë¼ëŠ” ìƒê°ì´ ë“¤ì–´ì„œ!

<aside>
ğŸ§

CAS versioning ê³¼ GC versioning ì˜ ìœ ì‚¬ì !

### CASì˜ ABA ë¬¸ì œì™€ GCì—ì„œì˜ ë²„ì €ë‹ì„ ì•Œì•„ë³´ì~~

### CAS ABA ë¬¸ì œ ìƒì„¸ ë¶„ì„

```java

// ABA ë¬¸ì œ ì‹œë‚˜ë¦¬ì˜¤
public class ABADemo {
    private AtomicReference<Node> head = new AtomicReference<>();

// ë¬¸ì œ ìƒí™©: Stackì—ì„œ pop ì—°ì‚°
    public Node pop() {
        Node oldHead, newHead;
        do {
            oldHead = head.get();// 1. A ì½ìŒ
            if (oldHead == null) return null;
            newHead = oldHead.next;// 2. A.next ì €ì¥

// ğŸ’¥ ì—¬ê¸°ì„œ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€:
// head: A â†’ B â†’ C
// pop() â†’ A ì œê±°, head = B
// pop() â†’ B ì œê±°, head = C
// push(A) â†’ head = A (A.next = C)
// ê²°ê³¼: headê°€ ë‹¤ì‹œ Aê°€ ë˜ì—ˆì§€ë§Œ A.nextê°€ ë³€ê²½ë¨!

        } while (!head.compareAndSet(oldHead, newHead));
        // 3. Aâ†’newHead ì‹œë„// ì„±ê³µí•˜ì§€ë§Œ newHeadëŠ” ì˜ëª»ëœ ê°’!

        return oldHead;
    }
}

```

## 2. CAS ABA ë¬¸ì œ í•´ê²°ì±…ë“¤

### ë²„ì „ ê¸°ë°˜ ë°©ë²•: AtomicStampedReference

ìŠ¤íƒ¬í”„(ë¼ê³  ì“°ê³  ì¹´ìš´í„°ë¼ê³  ì½ëŠ”ë‹¤) ë„ì…

```java
ì›ë˜: [ê°’: 100, ë²„ì „: 1]
ìŠ¤ë ˆë“œ Bê°€ ë³€ê²½: [ê°’: 50, ë²„ì „: 2] â†’ [ê°’: 100, ë²„ì „: 3]
ìŠ¤ë ˆë“œ A í™•ì¸: "ì–´? ê°’ì€ 100ì´ì§€ë§Œ ë²„ì „ì´ 1â†’3ìœ¼ë¡œ ë°”ë€Œì—ˆë„¤!"
```

**ì¥ì **

- ì¤‘ê°„ì— ë³€ê²½ì´ ìˆì—ˆë‹¤ëŠ” ê±¸ í™•ì‹¤íˆ ì•Œ ìˆ˜ ìˆìŒ

**ë‹¨ì **

- ì¶”ê°€ ë©”ëª¨ë¦¬ í•„ìš”, ë²„ì „ ì˜¤ë²„í”Œë¡œìš° ê°€ëŠ¥ì„±

### ë§ˆí‚¹ ê¸°ë°˜ ë°©ë²•: AtomicMarkableReference

í¬ì¸í„°ì— "ì‚­ì œ í‘œì‹œ" ë¹„íŠ¸ë¥¼ ë¶™ì„

```java
í¬ì¸í„° êµ¬ì¡°: [ì£¼ì†Œ | ë§ˆí‚¹ ë¹„íŠ¸]
ì •ìƒ ìƒíƒœ: [0x1000 | 0] (ë§ˆí‚¹ ì•ˆë¨)
ì‚­ì œ ì˜ˆì •: [0x1000 | 1] (ë§ˆí‚¹ë¨)
```

- ì‹¤ì œ ì‚­ì œ ì „ì— ë¨¼ì € ì‚­ì œ ì˜ˆì • í‘œì‹œë¥¼ í•´ ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ì´ë¯¸ ì²˜ë¦¬ ì¤‘ì¸ ë…¸ë“œë¥¼ ê±´ë“œë¦¬ì§€ ì•Šê²Œ ë¨

```java
import java.util.concurrent.atomic.AtomicMarkableReference;

class SafeNode {
    int data;
    // í¬ì¸í„° + ë§ˆí‚¹ ë¹„íŠ¸ë¥¼ í•¨ê»˜ ê´€ë¦¬
    AtomicMarkableReference<SafeNode> next;
    
    SafeNode(int data) {
        this.data = data;
        this.next = new AtomicMarkableReference<>(null, false);
    }
}

class SafeLinkedList {
    private SafeNode head;
    
    public boolean remove(int value) {
        retry: while (true) {
            SafeNode prev = head;
            SafeNode curr = prev.next.getReference();
            
            // valueë¥¼ ê°€ì§„ ë…¸ë“œ ì°¾ê¸°
            while (curr != null) {
                SafeNode succ = curr.next.getReference();
                boolean currMarked = curr.next.isMarked();
                
                // ğŸ” ì´ë¯¸ ì‚­ì œ í‘œì‹œëœ ë…¸ë“œëŠ” ê±´ë„ˆë›°ê¸°
                if (currMarked) {
                    // ì‚­ì œ í‘œì‹œëœ ë…¸ë“œë¥¼ ë¬¼ë¦¬ì ìœ¼ë¡œ ì œê±°
                    if (!prev.next.compareAndSet(curr, succ, false, false)) {
                        continue retry; // ì‹¤íŒ¨í•˜ë©´ ì²˜ìŒë¶€í„° ë‹¤ì‹œ
                    }
                    curr = succ;
                } else if (curr.data == value) {
                    break; // ëª©í‘œ ë…¸ë“œ ë°œê²¬!
                } else {
                    prev = curr;
                    curr = succ;
                }
            }
            
            if (curr == null) return false; // ë…¸ë“œë¥¼ ëª»ì°¾ìŒ
            
            SafeNode succ = curr.next.getReference();
            
            // ğŸ¯ í•µì‹¬: 2ë‹¨ê³„ ì‚­ì œ ê³¼ì •
            
            // 1ë‹¨ê³„: ë…¼ë¦¬ì  ì‚­ì œ (ë§ˆí‚¹)
            if (!curr.next.compareAndSet(succ, succ, false, true)) {
                continue retry; // ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ë¨¼ì € ë§ˆí‚¹í–ˆìŒ
            }
            
            // 2ë‹¨ê³„: ë¬¼ë¦¬ì  ì‚­ì œ (ì—°ê²° ëŠê¸°)
            prev.next.compareAndSet(curr, succ, false, false);
            // ğŸ’¡ ì´ ë‹¨ê³„ê°€ ì‹¤íŒ¨í•´ë„ ê´œì°®ìŒ! ë‹¤ë¥¸ ìŠ¤ë ˆë“œê°€ ë‚˜ì¤‘ì— ì •ë¦¬í•´ì¤„ê±°ì„
            
            return true;
        }
    }
}
```

CASë¡œ ì‚­ì œí•˜ëŠ” ì´ìœ ëŠ” **ì—¬ëŸ¬ ìŠ¤ë ˆë“œê°€ ë™ì‹œì— ê°™ì€ ìë£Œêµ¬ì¡°ë¥¼ ìˆ˜ì •í•  ë•Œ ì•ˆì „í•˜ê²Œ ë…¸ë“œë¥¼ ì œê±°í•˜ê¸° ìœ„í•´â€¦**

â‡’ ë³´ë‹¤ë³´ë‹ˆ ì§„ì§œ gcë‘ ìœ ì‚¬í•˜ì–ì•„ìš”

## GC

- **ë§ˆí‚¹ â‡’ ì²´í¬ë°•ìŠ¤ë‹¤!**  "ì‚´ì•„ìˆìŒ/ì£½ìŒ" ì´ì§„ ìƒíƒœë§Œ ê´€ë¦¬
- **ë²„ì €ë‹ â‡’ ì…€ë ‰íŠ¸ë°•ìŠ¤ë‹¤!** "0ì„¸ëŒ€/1ì„¸ëŒ€/2ì„¸ëŒ€" ë˜ëŠ” "ë¹¨ê°•/íŒŒë‘/ì´ˆë¡" ê°™ì€ ë‹¤ì¤‘ ìƒíƒœ ê´€ë¦¬

### ë§ˆí‚¹ ê¸°ë°˜ GC

### Serial GC (Mark-Sweep)

**ë‹¨ì¼ ìŠ¤ë ˆë“œë¡œ ìˆœì°¨ ì²˜ë¦¬**

```
í™ ë©”ëª¨ë¦¬: [A] [B] [C] [D] [E] [F]
ë§ˆí‚¹ ë‹¨ê³„: [âœ“] [ ] [âœ“] [âœ“] [ ] [âœ“] (ìˆœì°¨ì ìœ¼ë¡œ í•˜ë‚˜ì”©)
ìŠ¤ìœ„í”„:    [A] [X] [C] [D] [X] [F] (ì—°ì†ëœ ë¹ˆ ê³µê°„)
ê²°ê³¼:      ë©”ëª¨ë¦¬ ë‹¨í¸í™” ë°œìƒ
```

### Parallel GC (Mark-Sweep-Compact)

**ì—¬ëŸ¬ ìŠ¤ë ˆë“œë¡œ ë³‘ë ¬ ì²˜ë¦¬ + ì••ì¶•**

```

í™ ë©”ëª¨ë¦¬: [A] [B] [C] [D] [E] [F] [G] [H]
ìŠ¤ë ˆë“œ1:   [âœ“] [ ] [âœ“] [âœ“] (ì•ìª½ ë‹´ë‹¹)
ìŠ¤ë ˆë“œ2:   [ ] [âœ“] [âœ“] [ ] (ë’¤ìª½ ë‹´ë‹¹)
ìŠ¤ìœ„í”„ í›„: [A] [X] [C] [D] [X] [F] [G] [X]
ì••ì¶• í›„:   [A] [C] [D] [F] [G] [ë¹ˆê³µê°„...]
```

### CMS GC (Concurrent Mark-Sweep)

**ì• í”Œë¦¬ì¼€ì´ì…˜ê³¼ ë™ì‹œ ì‹¤í–‰**

```
ì• í”Œë¦¬ì¼€ì´ì…˜: â–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆâ–ˆ
Initial Mark: â–Œ (STW - ì§§ìŒ)
Concurrent:   â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ (ë°±ê·¸ë¼ìš´ë“œ ë§ˆí‚¹)
Remark:       â–Œ (STW - ì§§ìŒ)
Sweep:        â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘â–‘ (ë°±ê·¸ë¼ìš´ë“œ ì²­ì†Œ)

ë¬¸ì œì : ì••ì¶• ì—†ìŒ â†’ ë‹¨í¸í™” ëˆ„ì 
```

### ë²„ì „ ê¸°ë°˜ GC

### G1 GC (Garbage First)

**í™ì„ ì‘ì€ ì˜ì—­(Region)ìœ¼ë¡œ ë‚˜ëˆ„ì–´ ê´€ë¦¬**

```
í™ êµ¬ì¡° (ê° ì‚¬ê°í˜•ì´ Region):
â”Œâ”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”
â”‚Youngâ”‚Youngâ”‚ Old â”‚ Old â”‚
â”œâ”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¼â”€â”€â”€â”€â”€â”¤
â”‚Youngâ”‚Emptyâ”‚ Old â”‚Huge â”‚
â””â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”˜

GC ê³¼ì •:
1. ê°€ë¹„ì§€ ë§ì€ Region ìš°ì„  ìˆ˜ì§‘
2. Young â†’ Old ìŠ¹ê¸‰ ì‹œ ë‹¤ë¥¸ Regionìœ¼ë¡œ ì´ë™
3. ëª©í‘œ ì¤‘ë‹¨ ì‹œê°„ ë‚´ì—ì„œ ìµœëŒ€í•œ ìˆ˜ì§‘

Young GC: [Youngì˜ì—­ë“¤ë§Œ] â†’ ë¹ ë¦„
Mixed GC: [Young + Old ì¼ë¶€] â†’ ì¤‘ê°„
Full GC:  [ì „ì²´] â†’ ë“œë¬¼ê²Œ ë°œìƒ

```

### ZGC (Z Garbage Collector)

**ì»¬ëŸ¬ë“œ í¬ì¸í„° + ë™ì‹œ ì¬ë°°ì¹˜**

```

í¬ì¸í„° êµ¬ì¡° (64bit):
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚   ì£¼ì†Œê°’    â”‚M0â”‚M1â”‚R â”‚      ê¸°íƒ€          â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
              Mark bits  Relocation bit

ë™ì‘ ê³¼ì •:
1. Concurrent Mark: M0/M1 ë¹„íŠ¸ë¡œ ë§ˆí‚¹
2. Concurrent Relocation: ê°ì²´ ì´ë™í•˜ë©° í¬ì¸í„° ì—…ë°ì´íŠ¸
3. STW ì‹œê°„: í•­ìƒ 10ms ë¯¸ë§Œ

ì˜ˆì‹œ:
ê°ì²´ Aê°€ 0x1000 â†’ 0x2000ìœ¼ë¡œ ì´ë™
ê¸°ì¡´ í¬ì¸í„°: 0x1000|R=0 â†’ ì½ê¸° ì‹œ ìë™ìœ¼ë¡œ 0x2000|R=1ë¡œ ì—…ë°ì´íŠ¸

```

### Shenandoah GC

**ë¸Œë£©ìŠ¤ í¬ì¸í„° + ë™ì‹œ ì¬ë°°ì¹˜**

```

ê°ì²´ êµ¬ì¡°:
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚Brooks Pointerâ”‚   ì‹¤ì œ ë°ì´í„°   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
      â†“
  ì‹¤ì œ ìœ„ì¹˜ ê°€ë¦¬í‚´

ì¬ë°°ì¹˜ ê³¼ì •:
1. ê°ì²´ Aë¥¼ ìƒˆ ìœ„ì¹˜ë¡œ ë³µì‚¬
2. Brooks Pointerë§Œ ì—…ë°ì´íŠ¸
3. ì›ë³¸ ê°ì²´ëŠ” ë‚˜ì¤‘ì— ì •ë¦¬

Old Location: [Brooksâ†’New] [Data]
New Location: [Brooksâ†’Self] [Data]

```

**CAS ë²„ì €ë‹ê³¼ GC ë²„ì €ë‹ì˜ ê³µí†µì ~**

- **ìƒíƒœ ë³€í™” ê°ì§€â‡’**  ë©”ëª¨ë¦¬ê°€ ì˜ˆìƒê³¼ ë‹¤ë¥´ê²Œ ë³€ê²½ë˜ì—ˆëŠ”ì§€ í™•ì¸
- **ì›ìì  ì—…ë°ì´íŠ¸â‡’** ê°’ê³¼ ë²„ì „ì„ ë™ì‹œì— ë³€ê²½
- ì˜¤ë²„í—¤ë“œâ€¦
</aside>

## 2. Fetch-And-Add (FAA)

**ê°’ì„ ì½ê³  ë™ì‹œì— ë”í•˜ê¸°**ë¥¼ ì›ìì ìœ¼ë¡œ ìˆ˜í–‰í•©ë‹ˆë‹¤.

```java

// Hardware ë ˆë²¨
int fetch_and_add(int* ptr, int increment) {
    int old_value = *ptr;
    *ptr += increment;
    return old_value;// ì´ì „ ê°’ ë°˜í™˜
}

// Java êµ¬í˜„
AtomicInteger counter = new AtomicInteger(10);
int oldValue = counter.getAndAdd(5);// oldValue=10, counter=15
int newValue = counter.addAndGet(3);// newValue=18, counter=18

```

## 3. Test-And-Set (TAS)

**ê°’ì„ í™•ì¸í•˜ê³  ë™ì‹œì— ì„¤ì •**í•˜ëŠ” ì—°ì‚°ìœ¼ë¡œ, ìŠ¤í•€ë½ì˜ ê¸°ë°˜ì…ë‹ˆë‹¤.

```java

java
// Hardware ë ˆë²¨
boolean test_and_set(boolean* lock) {
    boolean old = *lock;
    *lock = true;
    return old;// ì´ì „ ê°’ ë°˜í™˜
}

// Javaë¡œ ìŠ¤í•€ë½ êµ¬í˜„
public class SpinLock {
    private AtomicBoolean locked = new AtomicBoolean(false);

    public void lock() {
        while (locked.getAndSet(true)) {// TAS ì—°ì‚°// ìŠ¤í•€ ëŒ€ê¸°
            Thread.onSpinWait();// CPU íŒíŠ¸
        }
    }

    public void unlock() {
        locked.set(false);
    }
}

```

ê·¸ í›„ë¡œ ì•½ê°„ ë…¸ì¼â€¦ì´ë¼ ê´€ë‘ 

ë™ì‹œì„± í•´ê²°ì„ ìë°”ë§Œìœ¼ë¡œ í•´ì•¼í• ë•Œ ìµœì„ ì˜.. ë°©ë²•ì€ ë¬´ì—‡ì´ì—ˆì„ê¹Œ?

<aside>
ğŸ§

### ReadWriteLockì˜ Write starvation ë¬¸ì œâ€¦

ì½ê¸° ìŠ¤ë ˆë“œë“¤: ğŸ“–ğŸ“–ğŸ“–ğŸ“–ğŸ“–ğŸ“–ğŸ“–ğŸ“–ğŸ“–ğŸ“– (ê³„ì† ë“¤ì–´ì˜´)
ì“°ê¸° ìŠ¤ë ˆë“œ:   ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ğŸ˜´ (ì˜ì›íˆ ëŒ€ê¸°...)

â‡’ ì“¸ìˆ˜ê°€ ì—†ì–´.. ì“°ê¸°ê°€ êµ¶ì–´ ì£½ì„ë•Œê¹Œì§€ ê¸°ë‹¤ë¦¼

### ê·¸ë˜ì„œ StampedLockì€?

ì½ê¸° ìŠ¤ë ˆë“œë“¤: ğŸ“–ğŸ“–ğŸ“– â†’ ì ê¹ ëŒ€ê¸°
ì“°ê¸° ìŠ¤ë ˆë“œ:           âœï¸ (ìš°ì„  ì²˜ë¦¬)
ì½ê¸° ìŠ¤ë ˆë“œë“¤:              ğŸ“–ğŸ“–ğŸ“– (ì´ì–´ì„œ ì§„í–‰)

### Optimistic Reading - StampedLockì˜ ì¥ì 

```java
// StampedLockì˜ ë¹„ë°€ ë¬´ê¸°
long stamp = lock.tryOptimisticRead();  // ë½ ì—†ì´ ì½ê¸° ì‹œë„! ğŸš€
// ë°ì´í„° ì½ê¸° (ë§¤ìš° ë¹ ë¦„)
if (lock.validate(stamp)) {             // ì¤‘ê°„ì— ë³€ê²½ ì—†ì—ˆë‚˜?
    return data;  // ì„±ê³µ! ë½ ì˜¤ë²„í—¤ë“œ 0
} else {
    // ì‹¤íŒ¨, ì¼ë°˜ ì½ê¸° ë½ìœ¼ë¡œ ì¬ì‹œë„
    stamp = lock.readLock();
    try {
        return readData();
    } finally {
        lock.unlockRead(stamp);
    }
}
```

*ReadWriteLock - ë¬´ê±°ì›€*
- ë‚´ë¶€ì— 2ê°œì˜ ë½ (ì½ê¸°ìš©, ì“°ê¸°ìš©)
- AQS(AbstractQueuedSynchronizer) ì‚¬ìš©
- ëŒ€ê¸° ìŠ¤ë ˆë“œ í ê´€ë¦¬

*StampedLock - ê°€ë²¼ì›€*
- ë‹¨ì¼ long ê°’ìœ¼ë¡œ ìƒíƒœ ê´€ë¦¬
- ë” ì ì€ ë©”ëª¨ë¦¬ ì‚¬ìš©
- ë” ì ì€ ê°ì²´ ìƒì„±

### **ì½ê¸° 90%, ì“°ê¸° 10% ìƒí™©**

ReadWriteLock:    â­â­â­ (ê´œì°®ìŒ)
StampedLock:      â­â­â­â­â­ (í›¨ì”¬ ë¹ ë¦„) // Optimistic Readingìœ¼ë¡œ ëŒ€ë¶€ë¶„ ë½ ì—†ì´ ì²˜ë¦¬

### **ì½ê¸° 50%, ì“°ê¸° 50% ìƒí™©**

ReadWriteLock:    â­â­ (ì“°ê¸° ê¸°ì•„ ë°œìƒ)
StampedLock:      â­â­â­â­ (ì“°ê¸° ìš°ì„ ê¶Œ ë³´ì¥)

### **ì“°ê¸°ê°€ ë§ì€ ìƒí™©**

ReadWriteLock:    â­â­â­
StampedLock:      â­â­â­â­ (ì•½ê°„ ë” ì¢‹ìŒ)

### **ReadWriteLockì˜ ë‹¨ì **

âŒ Writer Starvation (ì“°ê¸° ê¸°ì•„)
âŒ ìƒëŒ€ì ìœ¼ë¡œ ëŠë¦° ì„±ëŠ¥
âŒ ë” ë§ì€ ë©”ëª¨ë¦¬ ì‚¬ìš©
âœ… ì‚¬ìš©í•˜ê¸° ì‰¬ì›€
âœ… ì¬ì§„ì… ê°€ëŠ¥ (Reentrant)

### **StampedLockì˜ ë‹¨ì **

âœ… ë¹ ë¥¸ ì„±ëŠ¥
âœ… ì“°ê¸° ìš°ì„ ê¶Œ
âœ… Optimistic Reading
âŒ ì¬ì§„ì… ë¶ˆê°€ëŠ¥! (Non-Reentrant)
âŒ ì‚¬ìš©ë²•ì´ ë³µì¡í•¨
âŒ ìŠ¤íƒ¬í”„ ê´€ë¦¬ ì‹¤ìˆ˜ ìœ„í—˜

### **ReadWriteLock ì‚¬ìš©**

âœ… ì½”ë“œ ë‹¨ìˆœì„±ì´ ì¤‘ìš”í•œ ê²½ìš°
âœ… ì¬ì§„ì…ì´ í•„ìš”í•œ ê²½ìš°
âœ… íŒ€ì›ë“¤ì´ ìµìˆ™í•œ ë°©ì‹ ì„ í˜¸
âœ… ì„±ëŠ¥ì´ í¬ë¦¬í‹°ì»¬í•˜ì§€ ì•Šì€ ê²½ìš°

### **StampedLock ì‚¬ìš©**

âœ… ìµœê³  ì„±ëŠ¥ì´ í•„ìš”í•œ ê²½ìš°
âœ… ì½ê¸°ê°€ ì••ë„ì ìœ¼ë¡œ ë§ì€ ê²½ìš° (90%+)
âœ… ì“°ê¸° ê¸°ì•„ë¥¼ ë°©ì§€í•´ì•¼ í•˜ëŠ” ê²½ìš°
âœ… ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ì„ ì¤„ì´ê³  ì‹¶ì€ ê²½ìš°

StampedLockì€ ì„±ëŠ¥ì„ ìœ„í•´ ì¬ì§„ì…ì„ í¬ê¸°í–ˆë‹¤ê³  í•œë‹¤â€¦

### **ReentrantReadWriteLockì˜ ë‚´ë¶€**

```java

// ë³µì¡í•œ êµ¬ì¡° (ì¬ì§„ì… ì§€ì›ì„ ìœ„í•´)
class ReentrantReadWriteLock {
    private final ThreadLocal<Integer> readCount;// ìŠ¤ë ˆë“œë³„ ì½ê¸° ì¹´ìš´íŠ¸
    private Thread ownerThread;// ì†Œìœ  ìŠ¤ë ˆë“œ ì¶”ì 
    private int writeCount;// ì“°ê¸° ì¬ì§„ì… ì¹´ìš´íŠ¸
    // ... ë” ë§ì€ ì˜¤ë²„í—¤ë“œ
}

```

### **StampedLockì˜ ë‚´ë¶€**

```java

// ë‹¨ìˆœí•œ êµ¬ì¡° (ì„±ëŠ¥ ìµœìš°ì„ )
class StampedLock {
    private volatile long state;
    // ë‹¨ì¼ long ê°’ìœ¼ë¡œ ëª¨ë“  ìƒíƒœ ê´€ë¦¬
    // ìŠ¤ë ˆë“œ ì¶”ì  ì—†ìŒ â†’ ë¹ ë¦„!
    // ì¬ì§„ì… ì¹´ìš´íŠ¸ ì—†ìŒ â†’ ê°€ë²¼ì›€!
}

```

### **ë©”ëª¨ë¦¬ ì˜¤ë²„í—¤ë“œ ìµœì†Œí™”**

// ReentrantReadWriteLockì´ í•´ì•¼ í•˜ëŠ” ì¼ë“¤
âœ… í˜„ì¬ ë½ ì†Œìœ ìê°€ ëˆ„êµ¬ì¸ì§€ ê¸°ì–µ
âœ… ê° ìŠ¤ë ˆë“œê°€ ëª‡ ë²ˆ ë½ì„ ì¡ì•˜ëŠ”ì§€ ì¹´ìš´íŠ¸
âœ… ì½ê¸° ë½ì„ ì¡ì€ ìŠ¤ë ˆë“œë“¤ ëª©ë¡ ê´€ë¦¬
â†’ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ â¬†ï¸, ì„±ëŠ¥ â¬‡ï¸

// StampedLockì´ í•˜ëŠ” ì¼
âœ… ë½ ìƒíƒœë§Œ long í•˜ë‚˜ë¡œ ê´€ë¦¬
â†’ ë©”ëª¨ë¦¬ ì‚¬ìš©ëŸ‰ â¬‡ï¸, ì„±ëŠ¥ â¬†ï¸

### **ìŠ¤íƒ¬í”„(Stamp) ì‹œìŠ¤í…œì˜ í•œê³„**

```java

// StampedLockì˜ ìŠ¤íƒ¬í”„ ë°©ì‹
long stamp1 = lock.writeLock();// ìŠ¤íƒ¬í”„: 12345
long stamp2 = lock.writeLock();// ë§Œì•½ ì¬ì§„ì… ëœë‹¤ë©´ ìŠ¤íƒ¬í”„: ?????// ë¬¸ì œ: ì–´ë–¤ ìŠ¤íƒ¬í”„ë¡œ í•´ì œí•´ì•¼ í•˜ë‚˜?
lock.unlockWrite(stamp1);// ì´ê±°?
lock.unlockWrite(stamp2);// ì•„ë‹ˆë©´ ì´ê±°?// ReentrantReadWriteLockì€ ìŠ¤íƒ¬í”„ ì—†ì´ ë‹¨ìˆœí•˜ê²Œ
lock.unlock();// ê°€ì¥ ìµœê·¼ ë½ë§Œ í•´ì œ

```

### **ë°ë“œë½ ì‹œë‚˜ë¦¬ì˜¤**

â‡’ ReentrantLock ì‹œë¦¬ì¦ˆëŠ” ë°ë“œë½ì´ ë‚˜ì§€ ì•Šì§€â€¦ ê·¸ë ‡ë‹¤ë©´ ì•ˆì „ì„± ì¸¡ë©´ì—ì„  ê±”ê°€ ë” ì¢‹ì€ê²ƒ ì•„ë‹ê¹Œâ€¦

```java

StampedLock lock = new StampedLock();

public void outerMethod() {
    long stamp = lock.writeLock();// ë½ íšë“
    System.out.println("ì™¸ë¶€ ë©”ì„œë“œ ì‹œì‘");

    try {
        innerMethod();// ğŸ’£ í­íƒ„!
    } finally {
        lock.unlockWrite(stamp);
    }
}

public void innerMethod() {
    long stamp = lock.writeLock();// âŒ ì—¬ê¸°ì„œ ì˜ì›íˆ ë¸”ë¡œí‚¹!
    System.out.println("ë‚´ë¶€ ë©”ì„œë“œ");// ì ˆëŒ€ ì‹¤í–‰ ì•ˆ ë¨

    try {
// ì‘ì—…
    } finally {
        lock.unlockWrite(stamp);
    }
}

```

</aside>

### ReadWriteLock ì‚¬ìš©ì‹œ

```java
@Service
public class ReservationService {
    private final RoomReservationRepository roomReservationRepository;
    private final DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern("HH:mm");

    private final ConcurrentHashMap<Long, ReentrantReadWriteLock> roomLocks = new ConcurrentHashMap<>();

    public ReservationService(final RoomReservationRepository roomReservationRepository) {
        this.roomReservationRepository = roomReservationRepository;
    }

    public RoomReservation createReservation(final RoomReservationRequestDto request) {
        LocalTime startTime = LocalTime.parse(request.getFrom(), timeFormatter);
        LocalTime endTime = LocalTime.parse(request.getTo(), timeFormatter);

        validateReservationTime(startTime, endTime);

        ReentrantReadWriteLock roomLock = getRoomLock(request.getRoomId());

        roomLock.writeLock().lock();
        try {
            // ì‹œê°„ ì¶©ëŒ ê²€ì‚¬ ë° ì˜ˆì•½ ìƒì„±
            validateTimeConflict(request.getRoomId(), startTime, endTime);

            TimeSlice timeSlice = new TimeSlice(startTime, endTime);
            RoomReservation reservation = new RoomReservation(timeSlice, request.getUserId(), request.getRoomId());

            return roomReservationRepository.insert(reservation);
        } finally {
            roomLock.writeLock().unlock();
        }
    }

    public List<RoomReservation> getRoomReservations(long roomId) {
        ReentrantReadWriteLock roomLock = getRoomLock(roomId);

        roomLock.readLock().lock();
        try {
            return roomReservationRepository.findByRoomId(roomId);
        } finally {
            roomLock.readLock().unlock();
        }
    }

    public List<RoomReservation> getUserReservations(long userId) {
        return roomReservationRepository.findByUserId(userId);
    }

    private ReentrantReadWriteLock getRoomLock(long roomId) {
        return roomLocks.computeIfAbsent(roomId, k -> new ReentrantReadWriteLock());
    }

    private void validateReservationTime(LocalTime startTime, LocalTime endTime) {
        if (startTime.isAfter(endTime) || startTime.equals(endTime)) {
            throw new IllegalArgumentException("ì‹œì‘ ì‹œê°„ì€ ì¢…ë£Œ ì‹œê°„ë³´ë‹¤ ì´ì „ì´ì–´ì•¼ í•©ë‹ˆë‹¤.");
        }
    }

    private void validateTimeConflict(long roomId, LocalTime startTime, LocalTime endTime) {
        List<RoomReservation> existingReservations = roomReservationRepository.findByRoomId(roomId);

        for (RoomReservation reservation : existingReservations) {
            TimeSlice existingTime = reservation.getTime();

            if (isTimeOverlapping(startTime, endTime, existingTime.getStart(), existingTime.getEnd())) {
                throw new IllegalStateException("í•´ë‹¹ ì‹œê°„ëŒ€ì— ì´ë¯¸ ì˜ˆì•½ì´ ìˆìŠµë‹ˆë‹¤.");
            }
        }
    }

    private boolean isTimeOverlapping(LocalTime start1, LocalTime end1, LocalTime start2, LocalTime end2) {
        return start1.isBefore(end2) && start2.isBefore(end1);
    }
}
```

### StampedLock ì‚¬ìš©ì‹œ

```java
@Service
public class ReservationService {
    private final RoomReservationRepository roomReservationRepository;
    private final DateTimeFormatter timeFormatter = DateTimeFormatter.ofPattern("HH:mm");

    private final ConcurrentHashMap<Long, ExpiringLock> roomLocks = new ConcurrentHashMap<>();

    // ì •ë¦¬ ì‘ì—…
    private final ScheduledExecutorService lockCleanupExecutor = Executors.newSingleThreadScheduledExecutor(r -> {
        Thread t = new Thread(r, "LockCleanup");
        t.setDaemon(true);
        return t;
    });

    private static final long LOCK_EXPIRATION_MILLIS = 10 * 60 * 1000;
    private static final long CLEANUP_INTERVAL_MILLIS = 60 * 1000;

    public ReservationService(final RoomReservationRepository roomReservationRepository) {
        this.roomReservationRepository = roomReservationRepository;
    }

    @PostConstruct
    public void startLockCleaner() {
        lockCleanupExecutor.scheduleWithFixedDelay(
                this::cleanupExpiredLocks,
                CLEANUP_INTERVAL_MILLIS,
                CLEANUP_INTERVAL_MILLIS,
                TimeUnit.MILLISECONDS
        );
    }

    @PreDestroy
    public void shutdown() {
        lockCleanupExecutor.shutdown();
        try {
            if (!lockCleanupExecutor.awaitTermination(5, TimeUnit.SECONDS)) {
                lockCleanupExecutor.shutdownNow();
            }
        } catch (InterruptedException e) {
            lockCleanupExecutor.shutdownNow();
            Thread.currentThread().interrupt();
        }
    }

    public RoomReservation createReservation(final RoomReservationRequestDto request) {
        LocalTime startTime = LocalTime.parse(request.getFrom(), timeFormatter);
        LocalTime endTime = LocalTime.parse(request.getTo(), timeFormatter);

        validateReservationTime(startTime, endTime);

        StampedLock roomLock = getRoomLock(request.getRoomId());
        long stamp = roomLock.writeLock();
        try {
            validateTimeConflict(request.getRoomId(), startTime, endTime);

            TimeSlice timeSlice = new TimeSlice(startTime, endTime);
            RoomReservation reservation = new RoomReservation(timeSlice, request.getUserId(), request.getRoomId());

            return roomReservationRepository.insert(reservation);
        } finally {
            roomLock.unlockWrite(stamp);
        }
    }

    public List<RoomReservation> getUserReservations(long userId) {
        return roomReservationRepository.findByUserId(userId);
    }

    private StampedLock getRoomLock(long roomId) {
        return roomLocks.computeIfAbsent(roomId, id -> new ExpiringLock()).getLock();
    }

    private void cleanupExpiredLocks() {
        try {
            roomLocks.entrySet().removeIf(entry ->
                    entry.getValue().isExpired(LOCK_EXPIRATION_MILLIS)
            );
        } catch (Exception e) {
            System.err.println("ë½ ì •ë¦¬ ì‹¤íŒ¨: " + e.getMessage());
        }
    }

    private void validateReservationTime(LocalTime startTime, LocalTime endTime) {
        if (startTime.isAfter(endTime) || startTime.equals(endTime)) {
            throw new IllegalArgumentException("ì‹œì‘ ì‹œê°„ì€ ì¢…ë£Œ ì‹œê°„ë³´ë‹¤ ì´ì „ì´ì–´ì•¼ í•©ë‹ˆë‹¤.");
        }
    }

    private void validateTimeConflict(long roomId, LocalTime startTime, LocalTime endTime) {
        List<RoomReservation> existingReservations = roomReservationRepository.findByRoomId(roomId);

        for (RoomReservation reservation : existingReservations) {
            TimeSlice existingTime = reservation.getTime();
            if (isTimeOverlapping(startTime, endTime, existingTime.getStart(), existingTime.getEnd())) {
                throw new IllegalStateException("í•´ë‹¹ ì‹œê°„ëŒ€ì— ì´ë¯¸ ì˜ˆì•½ì´ ìˆìŠµë‹ˆë‹¤.");
            }
        }
    }

    private boolean isTimeOverlapping(LocalTime start1, LocalTime end1, LocalTime start2, LocalTime end2) {
        return start1.isBefore(end2) && start2.isBefore(end1);
    }
}
```

```java

import java.time.Instant;
import java.util.concurrent.locks.ReentrantReadWriteLock;
import java.util.concurrent.locks.StampedLock;

public class ExpiringLock {
    private final StampedLock lock = new StampedLock();
    private volatile Instant lastAccessed = Instant.now();

    public StampedLock getLock() {
        lastAccessed = Instant.now();
        return lock;
    }

    public boolean isExpired(long timeoutMillis) {
        return Instant.now().minusMillis(timeoutMillis).isAfter(lastAccessed);
    }
}
```

ì§„ì§œ ë…¸ë ¥í–ˆë‹¤â€¦

í•˜ì§€ë§Œ ë„ˆë¬´ ì½”í…Œì‹ìœ¼ë¡œ í‘¼ ê²ƒì¼ê¹Œ?

## ThreadLocal ì‚¬ìš© ì˜ˆì‹œ ì°¾ì•„ë³´ë‹¤ê°€ multi-tenancyë¥¼ ë°œê²¬~

5. **ë°ì´í„°ë² ì´ìŠ¤ ì»¨í…ìŠ¤íŠ¸ (Multi-tenancy)**

```java
@Component
public class TenantContextHolder {
    
    private static final ThreadLocal<String> tenantId = new ThreadLocal<>();
    
    public static void setTenantId(String tenant) {
        tenantId.set(tenant);
    }
    
    public static String getTenantId() {
        return tenantId.get();
    }
    
    public static void clear() {
        tenantId.remove();
    }
}

// ë™ì  ë°ì´í„°ì†ŒìŠ¤ ì„¤ì •
@Configuration
public class MultiTenantDataSourceConfig {
    
    @Bean
    public DataSource dataSource() {
        return new MultiTenantDataSource();
    }
}

public class MultiTenantDataSource implements DataSource {
    
    private Map<String, DataSource> dataSources = new HashMap<>();
    
    @Override
    public Connection getConnection() throws SQLException {
        String tenantId = TenantContextHolder.getTenantId();
        
        if (tenantId == null) {
            throw new SQLException("Tenant IDê°€ ì„¤ì •ë˜ì§€ ì•Šì•˜ìŠµë‹ˆë‹¤");
        }
        
        DataSource targetDataSource = dataSources.get(tenantId);
        if (targetDataSource == null) {
            throw new SQLException("Tenant [" + tenantId + "]ì˜ ë°ì´í„°ì†ŒìŠ¤ë¥¼ ì°¾ì„ ìˆ˜ ì—†ìŠµë‹ˆë‹¤");
        }
        
        return targetDataSource.getConnection();
    }
    
    // ë‹¤ë¥¸ DataSource ë©”ì„œë“œë“¤...
}
```

â‡’ ì‹¤ì œ ì‚¬ìš©

ê°ì¢… ContextHolderì— ì‚¬ìš©â€¦ (UserContextHolderë‚˜ TenentContextHolder â€¦)

```java
public final class TenantContext {
    private static final Logger log = LoggerFactory.getLogger(TenantContext.class);
    public TenantContext() {}

    private static final InheritableThreadLocal<String> currentTenant = new InheritableThreadLocal<>();
    ...
```

**1. ìºì‹œ ê¸°ë°˜ ë°ì´í„°ì†ŒìŠ¤ ê´€ë¦¬**

```java

private LoadingCache<String, DataSource> tenantDataSources;

// ìºì‹œì—ì„œ ë°ì´í„°ì†ŒìŠ¤ ì¡°íšŒ
DataSource ds = tenantDataSources.get(tenantCode);

```

**2. ThreadLocalê³¼ì˜ ì—°ë™**

```java

protected DataSource selectDataSource(String tenantIdentifier) {
    String tenantCode = TenantContext.getTenantCode();// ThreadLocalì—ì„œ ì¡°íšŒ
    DataSource ds = tenantDataSources.get(tenantCode);// ìºì‹œì—ì„œ ë°ì´í„°ì†ŒìŠ¤ ì¡°íšŒ
    return ds;
}

```

**3. ë™ì  ë°ì´í„°ì†ŒìŠ¤ ìƒì„±**

```java

private DataSource createAndConfigureDataSource(String tenantCode) {
    DataSourceInfo dataSourceInfo = fetchSchema(tenantCode);// ë©”íƒ€ì •ë³´ ì¡°íšŒ

// HikariDataSource ë™ì  ìƒì„±
    HikariDataSource ds = dataSourceProperties.initializeDataSourceBuilder()
        .username(dataSourceInfo.getUserName())
        .password(password)
        .url(dataSourceInfo.getPrefixUrl())
        .build();
}

```

**4. ìºì‹œ ì„¤ì • ë° ë¦¬ì†ŒìŠ¤ ê´€ë¦¬**

- `maximumSize`: ìµœëŒ€ 100ê°œ í…Œë„ŒíŠ¸ ë°ì´í„°ì†ŒìŠ¤ ìºì‹±
- `expireAfterAccess`: 10ë¶„ ë¯¸ì‚¬ìš©ì‹œ ìë™ í•´ì œ
- `removalListener`: ìºì‹œì—ì„œ ì œê±°ë  ë•Œ HikariDataSource ì •ë¦¬

**ì „ì²´ í”Œë¡œìš°**

1. HTTP ìš”ì²­ â†’ í•„í„°/ì¸í„°ì…‰í„°ì—ì„œ `TenantContext.setTenantCode()`
2. JPA/Hibernate íŠ¸ëœì­ì…˜ ì‹œì‘ â†’ `selectDataSource()` í˜¸ì¶œ
3. `TenantContext.getTenantCode()`ë¡œ í˜„ì¬ ìŠ¤ë ˆë“œì˜ í…Œë„ŒíŠ¸ ì½”ë“œ ì¡°íšŒ
4. ìºì‹œì—ì„œ í•´ë‹¹ í…Œë„ŒíŠ¸ì˜ ë°ì´í„°ì†ŒìŠ¤ ì¡°íšŒ (ì—†ìœ¼ë©´ ë™ì  ìƒì„±)
5. í•´ë‹¹ ë°ì´í„°ì†ŒìŠ¤ë¡œ DB ì—°ê²°

### ThreadLocalì€ ìƒì†ì´ ê°€ëŠ¥í•˜ë‹¤!

**ë¶€ëª¨ ìŠ¤ë ˆë“œì—ì„œ ìì‹ ìŠ¤ë ˆë“œë¡œ ê°’ì´ ìë™ ìƒì†**ë˜ëŠ” ThreadLocal

**ì¼ë°˜ ThreadLocal**

```java

ThreadLocal<String> threadLocal = new ThreadLocal<>();

// ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ ê°’ ì„¤ì •
threadLocal.set("main-value");

// ìƒˆ ìŠ¤ë ˆë“œ ìƒì„± ì‹œ ê°’ì´ ìƒì†ë˜ì§€ ì•ŠìŒ
new Thread(() -> {
    System.out.println(threadLocal.get());// null ì¶œë ¥
}).start();

```

**InheritableThreadLocal**

```java

InheritableThreadLocal<String> inheritableThreadLocal = new InheritableThreadLocal<>();

// ë©”ì¸ ìŠ¤ë ˆë“œì—ì„œ ê°’ ì„¤ì •
inheritableThreadLocal.set("main-value");

// ìƒˆ ìŠ¤ë ˆë“œ ìƒì„± ì‹œ ê°’ì´ ìë™ ìƒì†ë¨
new Thread(() -> {
    System.out.println(inheritableThreadLocal.get());// "main-value" ì¶œë ¥
}).start();

```

## ë©€í‹°í…Œë„Œì‹œì—ì„œ ì‚¬ìš©í•˜ëŠ” ì´ìœ 

**ë¹„ë™ê¸° ì²˜ë¦¬ ì‹œë‚˜ë¦¬ì˜¤**

```java

// HTTP ìš”ì²­ ìŠ¤ë ˆë“œì—ì„œ
TenantContext.setTenantCode("tenant-A");

// ë¹„ë™ê¸° ì‘ì—… ì‹¤í–‰
CompletableFuture.supplyAsync(() -> {
// ìì‹ ìŠ¤ë ˆë“œì—ì„œë„ tenant-Aê°€ ìœ ì§€ë¨
    String tenantCode = TenantContext.getTenantCode();// "tenant-A"
    return someService.processData();// ì˜¬ë°”ë¥¸ í…Œë„ŒíŠ¸ DB ì‚¬ìš©
});

// @Async ë©”ì„œë“œ í˜¸ì¶œ ì‹œì—ë„ í…Œë„ŒíŠ¸ ì •ë³´ ìœ ì§€
@Async
public void processAsync() {
    String tenantCode = TenantContext.getTenantCode();// ë¶€ëª¨ ìŠ¤ë ˆë“œ ê°’ ìƒì†
}

```

## ìƒì† ì‹œì ê³¼ ë°©ì‹

**ìƒì† ì‹œì :** ìì‹ ìŠ¤ë ˆë“œê°€ **ìƒì„±ë˜ëŠ” ìˆœê°„**ì— ë¶€ëª¨ì˜ ê°’ì„ ë³µì‚¬

```java

InheritableThreadLocal<String> context = new InheritableThreadLocal<>();

context.set("parent-value");

Thread childThread = new Thread(() -> {
// ìŠ¤ë ˆë“œ ìƒì„± ì‹œì ì˜ ë¶€ëª¨ ê°’ì´ ë³µì‚¬ë¨
    System.out.println(context.get());// "parent-value"

    context.set("child-modified");
    System.out.println(context.get());// "child-modified"
});

childThread.start();
childThread.join();

// ë¶€ëª¨ ìŠ¤ë ˆë“œëŠ” ì˜í–¥ ë°›ì§€ ì•ŠìŒ
System.out.println(context.get());// ì—¬ì „íˆ "parent-value"

```

**1. ìŠ¤ë ˆë“œ í’€ í™˜ê²½ì—ì„œì˜ ë¬¸ì œ**

```java

// ë¬¸ì œê°€ ë  ìˆ˜ ìˆëŠ” ìƒí™©
ExecutorService executor = Executors.newFixedThreadPool(5);

TenantContext.setTenantCode("tenant-A");
executor.submit(() -> {
// ìŠ¤ë ˆë“œ í’€ì˜ ì¬ì‚¬ìš©ëœ ìŠ¤ë ˆë“œëŠ” ì´ì „ ê°’ì„ ê°€ì§ˆ ìˆ˜ ìˆìŒ
    String tenant = TenantContext.getTenantCode();// ì˜ˆìƒê³¼ ë‹¤ë¥¼ ìˆ˜ ìˆìŒ
});

```

**2. ë©”ëª¨ë¦¬ ëˆ„ìˆ˜ ìœ„í—˜**

- ìì‹ ìŠ¤ë ˆë“œê°€ ì˜¤ë˜ ì‚´ì•„ìˆìœ¼ë©´ ë¶€ëª¨ì˜ ê°ì²´ê°€ GCë˜ì§€ ì•Šì„ ìˆ˜ ìˆìŒ
- ë°˜ë“œì‹œ `clear()` í˜¸ì¶œ í•„ìš”

ë©€í‹°í…Œë„Œì‹œì—ì„œëŠ” **ë¹„ë™ê¸° ì‘ì—…ì´ë‚˜ ë‚´ë¶€ì ìœ¼ë¡œ ìƒˆ ìŠ¤ë ˆë“œë¥¼ ìƒì„±í•˜ëŠ” ê²½ìš°**ì— í…Œë„ŒíŠ¸ ì •ë³´ê°€ ìë™ìœ¼ë¡œ ì „íŒŒë˜ì–´ ë§¤ìš° ìœ ìš©!

ê° ìŠ¤ë ˆë“œëŠ” ìì‹ ë§Œì˜ ThreadLocalMapì„ ê°€ì§€ê³  ìˆê³  ThreadLocalì„ í‚¤ë¡œ ì‚¬ìš©í•˜ì—¬ ê°’ì„ ì €ì¥

í•˜ë‚˜ì˜ ìŠ¤ë ˆë“œì—ì„œ ì—¬ëŸ¬ ê°œì˜ ThreadLocalì„ ì‚¬ìš©ê°€ëŠ¥!

ThreadLocalì€ í˜„ì¬ ìŠ¤ë ˆë“œì˜ ThreadLocalMapì„ ì œì–´

### Spring ìƒíƒœê³„ì—ì„œëŠ” ThreadLocalì„ ì‚¬ìš©í•˜ì—¬

- íŠ¸ëœì­ì…˜ ë™ê¸°í™” ê´€ë¦¬(TransactionSynchronizationManager)
- ì‚¬ìš©ì ì¸ì¦ ì •ë³´ ê´€ë¦¬(SecurityContextHolder)
- ì›¹ ìš”ì²­ì˜ attribute ê´€ë¦¬(RequestContextHolder) ë“±ì˜ ê¸°ëŠ¥ì„ ì œê³µ!

### ThreadLocalì˜ ì¥ì 

ê° ìŠ¤ë ˆë“œëŠ” ThreadLocalì— ì ‘ê·¼í•  ë•Œ ë‹¤ë¥¸ ìŠ¤ë ˆë“œì™€ ê²©ë¦¬ëœ ê°’ì„ ê°€ì§ˆ ìˆ˜ ìˆë‹¤

ê·¸ë¦¬ê³  ê³µìœ  ìì›ì´ ì—†ê¸° ë•Œë¬¸ì— synchronized í‚¤ì›Œë“œ ë“±ì„ ì‚¬ìš©í•´ì„œ ë™ê¸°í™”í•  í•„ìš”ê°€ ì—†ë‹¤

### ThreadLocalì„ ì‚¬ìš©í•  ë•Œ ì£¼ì˜í•  ì 

ìŠ¤ë ˆë“œí’€ì„ ì‚¬ìš©í•˜ë©´ ìŠ¤ë ˆë“œê°€ ì¬ì‚¬ìš©ë¨~

ì´ë•Œ ThreadLocalì— ì´ì „ ìŠ¤ë ˆë“œì˜ ê°’ì´ ë‚¨ì•„ìˆìœ¼ë©´ ì¬ì‚¬ìš©ëœ ìŠ¤ë ˆë“œê°€ ì˜¬ë°”ë¥´ì§€ ì•Šì€ ë°ì´í„°ë¥¼ ì°¸ì¡°

ìŠ¤ë ˆë“œê°€ ëë‚˜ëŠ” ì‹œì ì— remove() ë©”ì„œë“œë¥¼ í˜¸ì¶œí•˜ì—¬ ThreadLocalì— ì €ì¥ëœ ê°’ì„ ì œê±°í•´ ë¬¸ì œë¥¼ ë°©ì§€í•˜ì!

### ë¹„ë™ê¸°ì‘ì—…+ThreadLocal = HELL

@Async ì–´ë…¸í…Œì´ì…˜ â‡’ ìƒˆë¡œìš´ ìŠ¤ë ˆë“œì—ì„œ ë¹„ë™ê¸° ì‘ì—… â‡’ ë¹„ë™ê¸° ìŠ¤ë ˆë“œëŠ” ê¸°ì¡´ ìŠ¤ë ˆë“œì—ì„œ ThreadLocalì— ì €ì¥í•œ ê°’ì„ ì°¸ì¡°í•  ìˆ˜ ì—†ìŒâ€¦

ì´ ë¬¸ì œëŠ” Spring 4.3 ì´ìƒì—ì„œ ì œê³µí•˜ëŠ” TaskDecoratorë¥¼ ì‚¬ìš©í•˜ì—¬ ê¸°ì¡´ ìŠ¤ë ˆë“œì˜ ThreadLocal ê°’ì„ ë¹„ë™ê¸° ìŠ¤ë ˆë“œì— ë³µì‚¬í•˜ëŠ” ë°©ì‹ìœ¼ë¡œ í•´ê²°í•  ìˆ˜ ìˆê¸´ í•˜ì§€ë§Œâ€¦?

### ThreadLocal ëŒ€ì‹  ì“¸ ìˆ˜ ìˆëŠ” ê²ƒë“¤

- ThreadLocal ëŒ€ì‹  ë©”ì„œë“œ ì¸ìë¡œ ê°’ì„ ì „ë‹¬ â‡’ ìˆ²ì— ë‚˜ì˜¨ payIdë¥¼ ë©”ì„œë“œ ì§€ì—­ë³€ìˆ˜ë¡œ ì“°ëŠ”ê²ƒê³¼ ë¹„ìŠ·í•œ..ê°œë…..
- ConcurrentHashMapê³¼ ê°™ì´ thread-safeí•œ ìë£Œêµ¬ì¡°ë¥¼ ì‚¬ìš©í•˜ëŠ” ë°©ë²•
- @RequestScope ì–´ë…¸í…Œì´ì…˜ì„ ì‚¬ìš©í•˜ì—¬ HTTP ìš”ì²­ ë³„ë¡œ ë°ì´í„°ë¥¼ ê´€ë¦¬

### NamedThreadLocal

NamedThreadLocalì€ Springì—ì„œ ì œê³µí•˜ëŠ” ThreadLocalì˜ í™•ì¥ í´ë˜ìŠ¤

ë””ë²„ê¹…ì„ ì‰½ê²Œ í•˜ê¸° ìœ„í•´ ì´ë¦„ì„ ë¶€ì—¬í•  ìˆ˜ ìˆë‹¤!

â‡’ ê³ ëª¨ì”¨ë¥¼ ë³´ê³  ëŠë‚€..ë””ë²„ê¹…ì´ ì‰¬ì›Œì•¼ í•˜ëŠ”.. ì´ìœ ë¥¼ ìƒê°í•˜ë©° ë””ë²„ê¹… ì¹œí™”ì ì¸ ìƒíƒœê³„ë¥¼ ë§Œë“¤ì–´ë³´ì•„ìš”~

ì—¬ëŸ¬ ê°œì˜ ThreadLocalì„ ì‚¬ìš©í•  ë•Œ ì´ë¦„ì„ ëª…í™•íˆ ì„¤ì •í•˜ë©´ ì–´ë–¤ ëª©ì ì˜ ThreadLocalì¸ì§€ êµ¬ë¶„í•  ìˆ˜ ìˆì–´ ë””ë²„ê¹…ì´ ìš©ì´í•˜ë‹¤

## **ì¶”ê°€ ë ˆí¼ëŸ°ìŠ¤**

- [Gë§ˆì¼“ - Threadì˜ ê°œì¸ ìˆ˜ë‚©ì¥ ThreadLocal](https://dev.gmarket.com/62)
- [Baeldung - An Introduction to ThreadLocal in Java](https://www.baeldung.com/java-threadlocal)
- [ê°•ë‚¨ì–¸ë‹ˆ - Spring ì˜ ë™ê¸°, ë¹„ë™ê¸°, ë°°ì¹˜ ì²˜ë¦¬ì‹œ í•­ìƒ context ë¥¼ ìœ ì§€í•˜ê³  ë¡œê¹…í•˜ê¸°](https://blog.gangnamunni.com/post/mdc-context-task-decorator/)
- [ìš°ì•„í•œí˜•ì œë“¤ - ë¡œê·¸ ë° SQL ì§„ì…ì  ì •ë³´ ì¶”ê°€ ì—¬ì •](https://techblog.woowahan.com/13429/)
