# 📚 개발 도서 스터디 템플릿

## 🧠 1. 책을 읽기 전에
외부 연동시 발생가능한 문제점.. 내가 무엇을 몰랐을지 기대가 됨!

---

## 📂 2. 내용 정리
### 🌟 재시도
  - 실패 원인에 따라 재시도여부, 방법을 다르게 하자
  - 재시도 간격을 점진적으로 늘리는게 좋을 수도 있다


### 🌟 Http 커넥션 풀 (세팅 경험 공유..)
  - 1단계: 연결 풀 매니저 생성
PoolingHttpClientConnectionManager → 연결 풀 설정

  - 2단계: HTTP 클라이언트에 연결 풀 적용  
CloseableHttpClient → 실제 HTTP 요청을 처리하는 클라이언트

  ```java
      @Bean
      public PoolingHttpClientConnectionManager poolingConnectionManager() {
          PoolingHttpClientConnectionManager connectionManager = new PoolingHttpClientConnectionManager();
          connectionManager.setMaxTotal(MAX_CONNECTIONS_TOTAL);
          connectionManager.setDefaultMaxPerRoute(MAX_CONNECTIONS_PER_ROUTE);
          return connectionManager;
      }

      @Bean
      public CloseableHttpClient httpClient(PoolingHttpClientConnectionManager connectionManager) {
          return HttpClients.custom()
                  .setConnectionManager(connectionManager)
                  .build();
      }
  ```
  - 여기에다가 추가로, 커넥션 모니터링해서 만료커넥션, 유휴커넥션 정리를 손수 해줬음.. 
  - 커넥션풀을 사용하는데 모니터링까지 한다? 불필요한가?
  - 그치만 죽은 유휴 커넥션 때문에 외부 api 커넥션 문제가 생겼음. 아마 외부 서버의 keep alive timeout 때문에 유휴커넥션이 무효해진 것 같아서.. 강제 정리해줬단 말임!
  - ▼ 해당 모니터링 Bean 설정
  ```java
    @Bean
    public IdleConnectionMonitor idleConnectionMonitor(PoolingHttpClientConnectionManager connectionManager) {
        IdleConnectionMonitor monitor = new IdleConnectionMonitor(connectionManager);
        Thread monitorThread = new Thread(monitor);
        monitorThread.start();
        return monitor;
    }
  ```
  - 모니터링해서 정리하는 코드
  ```java
    @RequiredArgsConstructor
    public class IdleConnectionMonitor implements Runnable {

    private final PoolingHttpClientConnectionManager connectionManager;

    @Override
    public void run() {
        try {
            while (!Thread.currentThread().isInterrupted()) {
                synchronized (this) {
                    wait(5000);
                    // 만료 커넥션 & 유휴 커넥션 정리
                    connectionManager.closeExpiredConnections(); 
                    connectionManager.closeIdleConnections(15, TimeUnit.SECONDS);
                }
            }
        } catch (InterruptedException ex) {
            Thread.currentThread().interrupt();
        }
    }
  }
  ```


## 💬 3. 이야기하고 싶은 질문 / 포인트

> 읽으며 생긴 **의문**, **확인하고 싶은 개념**, **비판하고 싶은 주장** 등을 적습니다.

- ❓ **질문 1**: 처리하지 못할 요청은 빠른 에러 응답을 주기.. 좋긴한데.. 만약에 **꼭 처리해야 한다면?** 
- 내가 다루고 있는 콜 시스템에서는 처리실패가 곧바로 데이터 누락이다. **누락하지 않아야 하는 경우의 BEST는 뭘까?**
  - 그때 생각했던 방안 중 하나가 외부 API reject 요청은 따로 또 reject queue에 담아뒀다가 나중에 처리하는 방법이었음.. 그치만 외부 API의 지연 이슈가 장기 지속되면 메모리 리소스에 악영향을 줄텐데.. **과연 reject queue는 적당한 해결책이었을까?** reject가 없었어야 해서 무작정 큐에 담는 생각을 한 것임! (=> 지금은 목표 TPS를 맞출 수 있도록 쓰레드를 늘린 상태임.)


---

## 🎯 4. 정리 & 적용 아이디어

- **내가 배운 것 한 줄 요약**:  
  → `이 장을 통해 나는 _연동서비스관련발생가능문제_을 이해했다.`

---

## 🌟 5. 전체 리뷰

- **별점 평가** (⭐️ 5점 만점): `⭐️⭐️⭐️⭐️⭐️`
- **책에 대한 총평**: 
  - 연동서비스 관련해서 몰랐던 문제상황과 해결책을 알아서 좋았다. 특히 연동서비스 이중화는 내 머릿속에 없던 개념! 서킷브레이커 또한 서버내에서 사용하고 있는데, 뭔지 잘 몰랐어서 관심을 두지 않았음. 이번 기회에 코드 확인을 해봐야곘다는 열정이 생김.
  - 또, 외부 API 서버 지연 이슈때문에 다른 요청들에 지장이 가지 않도록 구성해야 한다는 성장을 얻음!!
