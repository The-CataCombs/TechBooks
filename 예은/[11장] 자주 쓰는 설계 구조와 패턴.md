# 📚 개발 도서 스터디 템플릿

## 🧠 1. 책을 읽기 전에



---

## 📂 2. 내용 정리 (자신의 언어로 요약)


### MSA
MSA에서 잊고 있었던 것들
	- DB를 공유하지 않는 원칙
	- 자신의 상태를 가짐 즉 API를 통한 접근이 핵심
	- 독립적 배포: 다른 마이크로서비스를 배포하지 않고도 변경/배포/출시 가능해야함
	- 모놀리식 안에서 구조, 품질 신경써서 잘 모듈화 가능 (modular monolithic)
		- chub는 컨테이너환경에서 돌아갈 수 있지만 모듈간 의존성이 있는 부분도 많다. 그치만 서버가 죽진 않는다.
		- 모듈적 특성이 강한 것 같다. 독립적으로 배포/출시하는 개념이 아니라 모듈간 호환이 이뤄지는 서비스기 때문에.. 
		- 쿠버네티스에서 돌아간다고 해서 완전한 MSA라고 보면 안될 것 같다는 생각을 하게 되었음


### DDD 
- DDD 
	- 애그리거트 없이 여러 테이블(orders, order_items, payments, shipping... )을 직접 조작하지 않는다. 
	- 비즈니스 로직을 애그리거트 내부에서 처리
	- 애그리거트 경계: 트랜잭션 경계 및 라이프사이클, 불변식 고려하기
```
애그리거트?
ex: 이커머스
  주문 애그리거트 {
    - Order (주문) ← 애그리거트 루트
    - OrderItem (주문상품)
    - Payment (결제)
  }

  배송 애그리거트 {
    - Shipping (배송) ← 별도 애그리거트 루트
  }

```

애그리거트 설계 원칙?
 -  한 번에 하나의 애그리거트만 수정
 ```java
  // ❌ 잘못된 예
  public void transferMoney(AccountId from, AccountId to, Money amount) {
      Account fromAccount = accountRepository.findById(from);
      Account toAccount = accountRepository.findById(to);

      fromAccount.withdraw(amount);  // 첫 번째 애그리거트 수정
      toAccount.deposit(amount);     // 두 번째 애그리거트 수정
      // 동시 수정으로 인한 데드락 위험!
  }

  // ✅ 올바른 예 (도메인 이벤트 사용)
  public void transferMoney(AccountId from, Money amount) {
      Account account = accountRepository.findById(from);
      account.withdraw(amount);

      // 이벤트 발행으로 다른 애그리거트에 알림
      domainEventPublisher.publish(new MoneyWithdrawnEvent(from, amount));
  }
```


 -  작게 유지하기
 ```
  // ❌ 너무 큰 애그리거트
  class Customer {
      private List<Order> orders;           // 수천개의 주문
      private List<Payment> payments;       // 수천개의 결제
      private List<Review> reviews;         // 수천개의 리뷰
      // → 메모리 부족, 성능 저하
  }

  // ✅ 적절한 크기
  class Customer {
      private CustomerInfo info;
      private CustomerPreferences preferences;
      // 주문, 결제, 리뷰는 별도 애그리거트로 분리
  }
```


- Repository 패턴과 함께
- [주의] 
 // DB 관계 ≠ 애그리거트 경계
 // 비즈니스 규칙이 기준이어야 함
 // JPA 사용시 여러 Repository 두었어도 논리적으로는 애그리거트 단위로 사용하도록 설계하는 것이 적절
  ```java
  // 애그리거트 단위로 Repository 생성
  @Repository
  public interface OrderRepository {
      Order findById(OrderId id);
      void save(Order order);  // 애그리거트 전체 저장
  }

  // ❌ 내부 객체별 Repository는 만들지 않음
  // OrderItemRepository - 생성하지 않음
  // PaymentRepository - 생성하지 않음

```


### 이벤트 기반 아키텍처

- 이벤트 구성을 어떤 `아키텍처`로 생각해본 적 없었어서 이번기회에 좋았다. 

---

## 💬 3. 이야기하고 싶은 질문 / 포인트

- 개발 다 하고 마지막에 코드 정리 & 개선하다보면 더 나은 구조로 변해가잖아 
	- 나는 예를들어 너무크게 컨트롤러 전체로 들어간 try-catch문을 개선하기 위해
	- 커스텀한 ExceptionResolvers를 등록했는데, 훨씬 명확해져서 좋았다. 
```java
@Configuration  
public class WebMvcConfig implements WebMvcConfigurer, WebMvcRegistrations {  
  
  ...
  
    /**  
     * 컨트롤러 에러 로그를 위해 커스텀한 ExceptionResolvers 를 등록한다.  
     */  
    @Override  
    public void configureHandlerExceptionResolvers(List<HandlerExceptionResolver> resolvers) {  
        resolvers.add(new CustomExceptionHandlerExceptionResolver());  
    }  
}
---
ExceptionResolver란?
Spring MVC에서 컨트롤러 예외를 처리하는 인터페이스
```

- 기존 구조 개선을 했던 사람들은 어느부분을 개선할 수 있었는지가 궁금하다. 


- 또 DDD를 쓰고 있는 부분이 있는지.. 우리는 거의 서비스레이어에서 테이블 직접 접근하는 코드 구현이 절대다수이다. 

---
