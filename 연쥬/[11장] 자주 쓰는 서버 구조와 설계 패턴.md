# 🏰 11장 자주 쓰는 서버 구조와 설계 패턴

## 🥅 책 읽기 전

- 말로만 듣던 DDD에 대해 알아봐야겠어요.

## 📚 책 내용 정리

### MVC(Model-View-Controller) 패턴

<image src="./images/11-1.png" width="300px" >

- 애플리케이션을 세 가지 역할로 구분하여 개발하는 아키텍처 패턴

```
- Model (모델)
  - 역할: 데이터와 비즈니스 로직 담당
  - 책임: 데이터 상태 관리, 비즈니스 규칙 처리
  - 특징: View와 Controller에 독립적
- View (뷰)
  - 역할: 사용자 인터페이스 담당
  - 책임: 데이터 표시, 사용자 입력 수집
  - 특징: Model의 데이터를 시각화
- Controller (컨트롤러)
  - 역할: 사용자 입력 처리 및 흐름 제어
  - 책임: Model과 View 사이의 중재
  - 특징: 사용자 요청을 Model에 전달하고 결과를 View에 반영
```

- 장점
  - 관심사 분리: 각 컴포넌트가 명확한 역할 수행
  - 재사용성: Model과 View를 독립적으로 재사용 가능
  - 유지보수성: 변경 시 영향 범위 최소화
  - 테스트 용이성: 각 계층별 독립적 테스트 가능
- 단점
  - 복잡성: 간단한 기능도 여러 파일로 분산
  - 성능: 계층 간 데이터 전달로 오버헤드 발생
  - 러닝 커브: 초기 이해 비용

### 계층형 아키텍처

- 애플리케이션을 수평적인 계층으로 나누어 각 계층이 특정 역할을 담당하는 구조

| 계층              | 설명                                                                                                                 |
| ----------------- | -------------------------------------------------------------------------------------------------------------------- |
| 표현(UI) 계층     | • 사용자와의 상호 작용을 담당<br>• 사용자의 요청 처리를 응용 계층에 위임<br>• MVC의 컨트롤러, 뷰가 여기에 해당       |
| 응용 계층         | • 사용자의 요청을 실제로 처리<br>• 모델이나 인프라 계층을 사용해 기능 구현<br>• 결과를 표현 계층에 반환 (MVC 서비스) |
| 도메인(모델) 계층 | • 도메인 로직을 구현<br>• 주문 모델의 취소 제약 조건과 상태 변경 등을 처리                                           |
| 인프라(영속) 계층 | • DB 연동이나 문자 발송 같은 구현 기술 지원<br>• DB 연동을 처리하는 DAO가 여기에 해당                                |

- 흩어지는 도메인 로직

  - 도메인 구현에 미숙한 개발자가 많음
  - 도메인 계층 없이 응용 계층과 인프라 계층만으로 구현하는 경우도 많음
  - 도메인 영역이 거의 없는 계층 구조에서는 도메인 로직이 인프라와 응용 계층으로 분산됨 -> 유지 보수 어려움
  - EX. 쿼리에 도메인 로직이 스며들어간 예시

    ```java
    // MemberDao.updateMemberStatus(id)의 쿼리
    update member set status = 20 where member_id = ? and status = 10

    // 아래 코드에는 어떠한 도메인 로직도 없음 => 어떤 조건일 때 상태가 변경되는지 확인하려면 쿼리를 뒤져야 함
    int cnt = mdao.updateMemberStatus(id);
    if (cnt == 0) {
        // 변경 건이 없으므로 변경 실패 처리
    }

    // 이렇게 도메인 로직이 쿼리나 컨트롤러와 같은 다른 계층에 흩어지는 것을 방지하려면 도메인 로직을 최대한 한 계층으로 모아야함
    // => 도메인 로직을 모으는 방법 중 하나: DDD의 전술 패턴 이용
    ```

- 장점
  - 단순성: 이해하기 쉬운 구조
  - 분리: 각 계층의 책임이 명확
  - 표준화: 널리 알려진 패턴
  - 테스트: 계층별 독립적 테스트 가능
- 단점
  - 성능: 계층 간 데이터 전달 오버헤드
  - 경직성: 계층을 건너뛰는 최적화 어려움
  - 복잡성: 간단한 기능도 모든 계층을 거쳐야 함

### DDD(Domain-Driven Design)와 전술 패턴

<image src="./images/11-3.png" width="300px" />

> 💡 로직이 복잡한 도메인을 구현할 때

- 비즈니스 도메인과 도메인 로직에 중점을 두는 소프트웨어 개발 접근법
- 구성 요소: 엔티티(Entity), 밸류(Value), 애그리거트(Aggregate), 리포지토리(Repository), 도메인 서비스(Domain Service), 도메인 이벤트(Domain Event)

### 마이크로서비스 아키텍처

<image src="./images/11-4.png" width="300px" />

- 애플리케이션을 작고 독립적인 서비스들로 구성하는 아키텍처 패턴
- 특징

  - 독립 배포: 각 서비스를 독립적으로 배포 가능
  - 기술 다양성: 서비스별로 다른 기술 스택 사용 가능
  - 팀 자율성: 서비스별 팀이 독립적으로 개발
  - 장애 격리: 한 서비스의 장애가 다른 서비스에 영향 최소화

- 장점

  - 확장성: 각 서비스를 독립적으로 확장 가능
  - 기술 다양성: 서비스별 최적의 기술 선택 가능
  - 팀 자율성: 팀별 독립적 개발과 배포
  - 장애 격리: 한 서비스 장애가 전체에 영향 최소화

- 단점
  - 복잡성: 분산 시스템의 복잡성 증가
  - 네트워크 지연: 서비스 간 네트워크 호출 오버헤드
  - 데이터 일관성: 분산 트랜잭션 관리의 어려움
  - 운영 복잡성: 모니터링, 로깅, 배포 등의 복잡성

### 이벤트 기반 아키텍처

<image src="./images/11-5.png" width="300px" />

- 이벤트의 생성, 감지, 소비를 기반으로 하는 아키텍처 패턴
  > 이벤트 생산자 --이벤트--> 이벤트 브로커(라우터) --이벤트--> 이벤트 소비자
- 장점
  - 느슨한 결합: 서비스 간 직접적인 의존성 제거
    - 생산자와 소비자가 직접 연결되지 않고 브로커를 통해 간접적으로 연결된다는 점
    - 서로 간섭하지 않고 독립적으로 배포할 수 있음
    - 새로운 소비자 추가도 용이
  - 확장성: 새로운 이벤트 핸들러 쉽게 추가 가능
  - 비동기 처리: 시스템 응답성 향상
  - 감사 추적: 모든 이벤트 기록으로 완전한 감사 로그
- 단점
  - 복잡성: 이벤트 흐름 추적의 어려움
  - eventual consistency: 최종 일관성으로 인한 복잡성
  - 중복 처리: 이벤트 중복 처리 방지 필요
  - 순서 보장: 이벤트 순서 보장의 어려움

### CQRS(Command Query Responsibility Segregation) 패턴

<image src="./images/11-6.png" width="300px" />

- 명령(쓰기)과 조회(읽기)를 분리하는 패턴
- 장점

  - 성능 최적화: 읽기와 쓰기를 독립적으로 최적화 가능
  - 확장성: 읽기와 쓰기 모델을 독립적으로 확장
  - 복잡한 쿼리: 읽기 전용 모델로 복잡한 조회 최적화
  - 기술 다양성: 읽기와 쓰기에 다른 데이터베이스 사용 가능

- 단점
  - 복잡성: 시스템 복잡도 증가
  - 일관성: 읽기와 쓰기 모델 간 최종 일관성
  - 개발 비용: 두 개의 모델 유지 관리
  - 학습 곡선: 팀의 CQRS 이해 필요

### 상황별로 어떤 아키텍처를 쓰는 게 좋을까?

| 패턴           | 복잡도 | 적합한 규모 | 개발 속도 | 확장성    | 주요 장점         | 주요 단점            |
| -------------- | ------ | ----------- | --------- | --------- | ----------------- | -------------------- |
| MVC            | 낮음   | 소규모      | 빠름      | 제한적    | 간단, 빠른 개발   | 큰 프로젝트에서 복잡 |
| 계층형         | 낮음   | 중소규모    | 보통      | 보통      | 표준화, 이해 쉬움 | 성능 오버헤드        |
| DDD            | 중간   | 중대규모    | 보통      | 좋음      | 비즈니스 중심     | 학습 곡선 높음       |
| 마이크로서비스 | 높음   | 대규모      | 느림      | 매우 좋음 | 독립성, 확장성    | 운영 복잡성          |
| 이벤트 기반    | 중간   | 중대규모    | 보통      | 매우 좋음 | 느슨한 결합       | 복잡한 디버깅        |
| CQRS           | 높음   | 대규모      | 느림      | 매우 좋음 | 성능 최적화       | 개발 비용 높음       |

## 👀 더 찾아본 것

### DDD

- 출처: [NHN FORWARD 22 DDD 뭣이 중헌디?](https://youtu.be/6w7SQ_1aJ0A?si=IKPAd8sAJB52ewxT)

#### 설계 순서

1. 비즈니스 도메인에서 문제 도메인 추출
2. 문제 도메인을 서브 도메인으로 나누기
   <image src="./images/11-7.png" width="500px" />
3. 문제 공간 식별
   <image src="./images/11-8.png" width="500px" />
   1. 핵심: 난이도 최상 (in-house)
   2. 일반: 난이도 상 (솔루션 구매)
   3. 지원: 난이도 하 (in-house, 하청)
4. 문제 공간을 해결 공간으로 (개발자가 추가됨)
   <image src="./images/11-9.png" width="500px" />
   - Bounded-Context 간 경계를 설정하고 관계 설정

#### 브라운 필드 전략적 설계

<image src="./images/11-10.png" width="500px" />

- Big Ball of Mud가 될 때 전략적 설계 적용하기
- 전략적 설계 시 유용한 도구
  - 사용 사례(use-case) 분석 => top-down 방식
  - 이벤트 스토밍(Event Storming) => bottom-up 방식
  - Business Model 분석
- 중요한건 언제 어디서나 Ubiquitous-Language를 이용해 소통한다!

#### Bounded-Context

- 이름만 같은데 다른 개념이 나오는 경우가 있음
  <image src="./images/11-11.png" width="500px" />

  - BoundedContext안에서는 개념이 명확해짐

- 동일한 개념 모델이지만 여러 문맥에 다 의존하는 경우도 있음
  <image src="./images/11-12.png" width="500px" />

  - 컨텍스트별로 필요한 기능을 수행하는 모델로 분리
  - 경계가 달라질 수 있음

- Bounded Context안에 하위 도메인 여러개 존재할 수도 있고, 1개만 존재할 수도 있음

- Bounded Context별 전술 선정
  <image src="./images/11-14.png" width="500px" />

- Bounded Context별로 팀 구성해도 좋음

#### Context-Map

- Bounded-Context간 매핑 관계 설정
  <image src="./images/11-17.png" width="500px" />
  <image src="./images/11-16.png" width="500px" />

## 🤔 궁금한 것

-

## 🎀 소감

- 대규모 프로젝트를 DDD로 설계해보는 경험을 쌓으면 정말 재밌을 것 같아요.
